{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Permio is a Resource-Specific Role-Based Access Control (RBAC) system designed for modern applications that require fine-grained and scalable permission management. With an API-First approach, authentication-agnostic design, and a built-in UI Dashboard, Permio empowers developers and admins to define and enforce permissions at the most granular level.</p> <p>Manage your organization visually via the dashboard at app.perms.io or programmatically via the API.</p>"},{"location":"#key-features","title":"\ud83d\udd27 Key Features","text":""},{"location":"#resource-level-rbac","title":"\u2705 Resource-Level RBAC","text":"<p>Permio enables access control at the individual object level. You can define access rules for specific instances of data (e.g., /project/42, /user/1234), enabling secure and flexible permissioning for complex apps.</p>"},{"location":"#hierarchical-inheritance","title":"\ud83c\udfd7\ufe0f Hierarchical Inheritance","text":"<p>Define roles and permissions at higher levels (e.g., /user) and let them automatically propagate to nested resources (e.g., /user/1234, /user/1234/documents/5678).</p>"},{"location":"#api-first-design","title":"\ud83d\udd0c API-First Design","text":"<ul> <li>REST API for web applications</li> <li>gRPC API for backend services</li> <li>Authentication-agnostic - works with any auth provider</li> <li>gRPC clients for Go, Rust, Python, Java, TypeScript</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Ready to get started? Follow our comprehensive guide:</p> <p>\ud83d\udcd6 Quick Start Guide \u2192</p> <p>Learn the fundamentals of access control:</p> <p>\ud83d\udd10 IAM Fundamentals \u2192</p> <p>Understand how Permio works:</p> <p>\u2699\ufe0f How It Works \u2192</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":""},{"location":"#core-concepts","title":"Core Concepts","text":"<ul> <li>How It Works - Understanding resource-specific RBAC</li> <li>IAM Fundamentals - Identity and access management fundamentals</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Organizations &amp; Projects - Manage your organization structure</li> <li>Permissions - Create and manage permissions</li> <li>Pagination - Handle large result sets efficiently</li> </ul>"},{"location":"#integration-examples","title":"Integration Examples","text":"<ul> <li>Multi-tenant Applications - Isolate tenant data securely</li> <li>Document Management Systems - File-level access control</li> <li>Project-based Access - Team and environment permissions</li> </ul>"},{"location":"#support","title":"\ud83d\udcac Support","text":"<p>Need help getting started or have questions?</p> <ul> <li>\ud83d\udce7 Email: support@perms.io</li> <li>\ud83d\udcac Discord: Join our community</li> <li>\ud83d\udcd6 Documentation: Browse these docs for detailed guides</li> <li>\ud83d\udc1b Issues: Report bugs or request features</li> </ul>"},{"location":"how-it-works/","title":"How It Works","text":"<p>Permio implements Resource-Specific Role-Based Access Control (RBAC), a modern approach to access management that provides fine-grained control over who can access what resources in your application.</p>"},{"location":"how-it-works/#core-concepts","title":"Core Concepts","text":""},{"location":"how-it-works/#1-resources-and-resource-uris","title":"1. Resources and Resource URIs","text":"<p>Resources are the core building blocks of Permio's permission system. A resource represents any object, entity, or endpoint in your application that you want to protect.</p> <p>Resources are identified by Resource URIs - hierarchical path strings that uniquely identify each resource:</p> <pre><code>/organisation/123\n/organisation/123/project/456\n/organisation/123/project/456/document/789\n/user/1234\n/user/1234/profile\n/tenant/abc/workspace/def/file/ghi\n</code></pre>"},{"location":"how-it-works/#uri-structure-best-practices","title":"URI Structure Best Practices","text":"<ul> <li>Start with a slash: All URIs begin with <code>/</code></li> <li>Use logical hierarchy: Organize resources in a tree-like structure</li> <li>Include identifiers: Use specific IDs to identify individual resources</li> <li>Keep it readable: Use descriptive names that reflect your application structure</li> </ul> Good ExamplesAvoid <pre><code>/project/456/documents/789\n/user/1234/settings/notifications\n/tenant/abc/billing/invoices/invoice-2024-001\n</code></pre> <pre><code>project-456-document-789\n/users/1234-settings-notifications\n/random/deep/nesting/without/purpose\n</code></pre>"},{"location":"how-it-works/#2-principals","title":"2. Principals","text":"<p>Principals are entities that can be granted permissions. In most cases, these are users, but they can also represent:</p> <ul> <li>Users: Individual people with accounts</li> <li>Service accounts: Applications or automated systems</li> <li>API keys: Programmatic access tokens</li> <li>External systems: Third-party integrations</li> </ul> <p>Principals are identified by unique strings (usually user IDs or API key identifiers).</p>"},{"location":"how-it-works/#3-permissions","title":"3. Permissions","text":"<p>Permissions define specific actions that can be performed. They represent the atomic level of access control:</p> <pre><code>{\n  \"name\": \"document.read\",\n  \"description\": \"Allows reading documents\"\n}\n</code></pre>"},{"location":"how-it-works/#permission-naming-convention","title":"Permission Naming Convention","text":"<p>Use dot notation for hierarchical permission names:</p> <ul> <li><code>document.read</code> - Read documents</li> <li><code>document.write</code> - Create/update documents  </li> <li><code>document.delete</code> - Delete documents</li> <li><code>user.profile.update</code> - Update user profiles</li> <li><code>billing.invoice.create</code> - Create billing invoices</li> </ul>"},{"location":"how-it-works/#4-roles","title":"4. Roles","text":"<p>Roles are collections of permissions that can be assigned as a group. They simplify permission management by grouping related permissions together:</p> <pre><code>{\n  \"name\": \"document_editor\",\n  \"description\": \"Can read and write documents\",\n  \"permissions\": [\"document.read\", \"document.write\"]\n}\n</code></pre> <p>Common role patterns: - Viewer roles: Read-only access (<code>*.read</code> permissions) - Editor roles: Read and write access - Admin roles: Full access including delete permissions - Custom roles: Specific combinations for your use case</p>"},{"location":"how-it-works/#hierarchical-permission-inheritance","title":"Hierarchical Permission Inheritance","text":"<p>One of Permio's most powerful features is hierarchical inheritance. Permissions granted on parent resources automatically apply to all child resources.</p>"},{"location":"how-it-works/#how-inheritance-works","title":"How Inheritance Works","text":"<pre><code>/organization/123\n\u251c\u2500\u2500 /organization/123/project/456\n\u2502   \u251c\u2500\u2500 /organization/123/project/456/document/789\n\u2502   \u2514\u2500\u2500 /organization/123/project/456/document/101\n\u2514\u2500\u2500 /organization/123/project/789\n    \u2514\u2500\u2500 /organization/123/project/789/document/456\n</code></pre> <p>If a user has <code>document.read</code> permission on <code>/organization/123</code>, they automatically have read access to: - All projects in the organization - All documents in those projects - Any future resources created under this organization</p>"},{"location":"how-it-works/#inheritance-examples","title":"Inheritance Examples","text":""},{"location":"how-it-works/#example-1-organization-wide-access","title":"Example 1: Organization-wide Access","text":"<p><pre><code>{\n  \"principal\": \"admin-user-123\",\n  \"resource_uri\": \"/organization/abc\",\n  \"permissions\": [\"organization.admin\"]\n}\n</code></pre> Result: Admin can manage the entire organization and all its contents.</p>"},{"location":"how-it-works/#example-2-project-specific-access","title":"Example 2: Project-specific Access","text":"<p><pre><code>{\n  \"principal\": \"project-manager-456\",\n  \"resource_uri\": \"/organization/abc/project/web-app\",\n  \"permissions\": [\"project.manage\"]\n}\n</code></pre> Result: Manager can handle all aspects of the web-app project, but not other projects.</p>"},{"location":"how-it-works/#example-3-document-specific-access","title":"Example 3: Document-specific Access","text":"<p><pre><code>{\n  \"principal\": \"editor-789\",\n  \"resource_uri\": \"/organization/abc/project/web-app/document/readme\",\n  \"permissions\": [\"document.edit\"]\n}\n</code></pre> Result: Editor can only modify this specific document.</p>"},{"location":"how-it-works/#permission-resolution-process","title":"Permission Resolution Process","text":"<p>When checking permissions, Permio follows this resolution process:</p> <ol> <li>Direct Match: Check for permissions directly assigned to the specific resource</li> <li>Parent Traversal: Walk up the URI hierarchy checking each parent level</li> <li>Role Expansion: Expand roles into their constituent permissions</li> <li>Inheritance Application: Apply inherited permissions from parent resources</li> <li>Final Decision: Grant access if any permission grants are found</li> </ol>"},{"location":"how-it-works/#authentication-vs-authorization","title":"Authentication vs Authorization","text":"<p>Permio focuses purely on authorization (what can you do?) and is completely authentication-agnostic (who are you?).</p>"},{"location":"how-it-works/#authentication-external","title":"Authentication (External)","text":"<ul> <li>Identity verification: Login, passwords, MFA</li> <li>Token issuance: JWTs, session cookies, API keys</li> <li>Identity providers: Auth0, Firebase Auth, custom systems</li> </ul>"},{"location":"how-it-works/#authorization-permio","title":"Authorization (Permio)","text":"<ul> <li>Permission checking: Can user X perform action Y on resource Z?</li> <li>Access control: Role and permission management</li> <li>Policy enforcement: Hierarchical permission inheritance</li> </ul>"},{"location":"how-it-works/#integration-flow","title":"Integration Flow","text":"<pre><code>1. Client \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 App: Request with token\n2. App \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 AuthProvider: Validate token  \n3. AuthProvider \u2500\u2500\u2500\u2500\u2192 App: User identity\n4. App \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Permio: Check permissions\n5. Permio \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 App: Permission result\n6. App \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Client: Allow/block response\n</code></pre> <ol> <li>Client sends request with authentication token</li> <li>Your application validates the token with your auth provider</li> <li>Auth provider confirms identity and returns user info</li> <li>Your application calls Permio to check permissions</li> <li>Permio returns permission check result</li> <li>Your application allows or denies the request</li> </ol>"},{"location":"how-it-works/#api-first-architecture","title":"API-First Architecture","text":"<p>Permio is built with an API-first philosophy, offering multiple access methods:</p>"},{"location":"how-it-works/#rest-api","title":"REST API","text":"<p>Standard HTTP endpoints for web applications: <pre><code>curl -X POST \"https://api.perms.io/permissions-service/v1/permissions/check\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -d '{\"principal_id\": \"user_123\", \"resource_uris\": [\"/documents/doc_456\"], \"permissions\": [\"document.read\"]}'\n</code></pre></p>"},{"location":"how-it-works/#grpc-api","title":"gRPC API","text":"<p>High-performance binary protocol for backend services: <pre><code>resp, err := client.Check(ctx, &amp;permissionsv1.CheckPermissionRequest{\n    PrincipalId:  \"user_123\",\n    ResourceUris: []string{\"/documents/doc_456\"},\n    Permissions:  []string{\"document.read\"},\n})\n</code></pre></p>"},{"location":"how-it-works/#dashboard-ui","title":"Dashboard UI","text":"<p>Web interface for visual management: - Create and manage permissions and roles - View permission assignments - Monitor usage and analytics - Manage organizations and projects</p>"},{"location":"how-it-works/#performance-and-scalability","title":"Performance and Scalability","text":""},{"location":"how-it-works/#performance-best-practices","title":"Performance Best Practices","text":""},{"location":"how-it-works/#1-batch-permission-checks","title":"1. Batch Permission Checks","text":"<pre><code>{\n  \"principal_id\": \"user_123\",\n  \"resource_uris\": [\"/doc/1\", \"/doc/2\", \"/doc/3\"],\n  \"permissions\": [\"read\", \"write\"]\n}\n</code></pre>"},{"location":"how-it-works/#2-use-specific-resource-uris","title":"2. Use Specific Resource URIs","text":"<pre><code># Good: Specific resource\n/project/456/document/789\n\n# Avoid: Overly broad checks\n/project/456/*\n</code></pre>"},{"location":"how-it-works/#3-design-efficient-hierarchies","title":"3. Design Efficient Hierarchies","text":"<pre><code># Good: Logical hierarchy\n/tenant/abc/workspace/def/project/ghi\n\n# Avoid: Flat structure requiring many checks\n/resource-tenant-abc-workspace-def-project-ghi\n</code></pre>"},{"location":"how-it-works/#common-implementation-patterns","title":"Common Implementation Patterns","text":""},{"location":"how-it-works/#1-multi-tenant-applications","title":"1. Multi-tenant Applications","text":"<p>Isolate tenants using hierarchical resource URIs:</p> <pre><code># Tenant A resources\n/tenant/company-a/projects/web-app\n/tenant/company-a/users/user-123\n\n# Tenant B resources  \n/tenant/company-b/projects/mobile-app\n/tenant/company-b/users/user-456\n</code></pre> <p>Grant access at the tenant level: <pre><code>{\n  \"principal\": \"admin@company-a.com\",\n  \"resource_uri\": \"/tenant/company-a\",\n  \"roles\": [\"tenant_admin\"]\n}\n</code></pre></p>"},{"location":"how-it-works/#2-document-management-system","title":"2. Document Management System","text":"<pre><code># Workspace hierarchy\n/workspace/engineering/folders/backend\n/workspace/engineering/folders/backend/documents/api-spec.md\n/workspace/marketing/folders/campaigns\n/workspace/marketing/folders/campaigns/documents/q4-plan.pdf\n</code></pre> <p>Role assignments: <pre><code>[\n  {\n    \"principal\": \"john@company.com\",\n    \"resource_uri\": \"/workspace/engineering\",\n    \"roles\": [\"workspace_admin\"]\n  },\n  {\n    \"principal\": \"jane@company.com\", \n    \"resource_uri\": \"/workspace/engineering/folders/backend\",\n    \"roles\": [\"folder_editor\"]\n  }\n]\n</code></pre></p>"},{"location":"how-it-works/#3-project-based-access-control","title":"3. Project-based Access Control","text":"<pre><code># Project structure\n/organization/acme/project/web-app\n/organization/acme/project/web-app/environments/production\n/organization/acme/project/web-app/environments/staging\n/organization/acme/project/mobile-app\n</code></pre> <p>Team permissions: <pre><code>[\n  {\n    \"principal\": \"dev-team\",\n    \"resource_uri\": \"/organization/acme/project/web-app/environments/staging\", \n    \"permissions\": [\"deploy\", \"debug\", \"monitor\"]\n  },\n  {\n    \"principal\": \"ops-team\",\n    \"resource_uri\": \"/organization/acme/project/web-app/environments/production\",\n    \"permissions\": [\"deploy\", \"monitor\"] \n  }\n]\n</code></pre></p>"},{"location":"how-it-works/#security-considerations","title":"Security Considerations","text":""},{"location":"how-it-works/#principle-of-least-privilege","title":"Principle of Least Privilege","text":"<ul> <li>Grant minimal permissions required for each role</li> <li>Regularly audit and review permission assignments</li> <li>Use time-limited permissions where appropriate</li> <li>Implement permission approval workflows for sensitive resources</li> </ul>"},{"location":"how-it-works/#resource-uri-validation","title":"Resource URI Validation","text":"<p>Always validate resource URIs in your application:</p> <pre><code>func validateResourceURI(uri string) error {\n    if !strings.HasPrefix(uri, \"/\") {\n        return errors.New(\"resource URI must start with /\")\n    }\n\n    if strings.Contains(uri, \"..\") {\n        return errors.New(\"resource URI cannot contain path traversal\")\n    }\n\n    // Add more validation as needed\n    return nil\n}\n</code></pre>"},{"location":"how-it-works/#permission-boundary-enforcement","title":"Permission Boundary Enforcement","text":"<p>Implement checks at multiple levels:</p> <pre><code>// 1. Application level - before business logic\nif !hasPermission(userID, resourceURI, \"document.read\") {\n    return errors.New(\"access denied\")\n}\n\n// 2. API gateway level - before reaching your service\n// 3. Database level - row-level security policies\n</code></pre>"},{"location":"how-it-works/#integration-examples","title":"Integration Examples","text":""},{"location":"how-it-works/#expressjs-middleware","title":"Express.js Middleware","text":"<pre><code>function requirePermission(resource, permission) {\n  return async (req, res, next) =&gt; {\n    const userId = req.user.id;\n\n    const hasAccess = await permio.check({\n      principal_id: userId,\n      resource_uris: [resource],\n      permissions: [permission]\n    });\n\n    if (hasAccess.passed) {\n      next();\n    } else {\n      res.status(403).json({ error: 'Access denied' });\n    }\n  };\n}\n\n// Usage\napp.get('/documents/:id', \n  requirePermission('/documents/' + req.params.id, 'document.read'),\n  getDocument\n);\n</code></pre>"},{"location":"how-it-works/#django-decorator","title":"Django Decorator","text":"<pre><code>def require_permission(resource_template, permission):\n    def decorator(view_func):\n        def wrapper(request, *args, **kwargs):\n            user_id = request.user.id\n            resource_uri = resource_template.format(**kwargs)\n\n            result = permio_client.check(\n                principal_id=user_id,\n                resource_uris=[resource_uri],\n                permissions=[permission]\n            )\n\n            if not result.passed:\n                return HttpResponseForbidden(\"Access denied\")\n\n            return view_func(request, *args, **kwargs)\n        return wrapper\n    return decorator\n\n# Usage\n@require_permission('/documents/{document_id}', 'document.read')\ndef get_document(request, document_id):\n    # View logic here\n    pass\n</code></pre>"},{"location":"how-it-works/#go-service","title":"Go Service","text":"<pre><code>type PermissionChecker struct {\n    client permissionsv1.PermissionsServiceClient\n}\n\nfunc (p *PermissionChecker) CheckAccess(ctx context.Context, userID, resourceURI, permission string) error {\n    resp, err := p.client.Check(ctx, &amp;permissionsv1.CheckPermissionRequest{\n        PrincipalId:  userID,\n        ResourceUris: []string{resourceURI},\n        Permissions:  []string{permission},\n    })\n\n    if err != nil {\n        return fmt.Errorf(\"permission check failed: %w\", err)\n    }\n\n    if !resp.Passed {\n        return fmt.Errorf(\"access denied to %s on %s\", permission, resourceURI)\n    }\n\n    return nil\n}\n\n// Usage in handlers\nfunc (h *DocumentHandler) GetDocument(w http.ResponseWriter, r *http.Request) {\n    userID := getUserFromContext(r.Context())\n    documentID := mux.Vars(r)[\"id\"]\n    resourceURI := fmt.Sprintf(\"/documents/%s\", documentID)\n\n    if err := h.permChecker.CheckAccess(r.Context(), userID, resourceURI, \"document.read\"); err != nil {\n        http.Error(w, \"Access denied\", http.StatusForbidden)\n        return\n    }\n\n    // Proceed with document retrieval\n}\n</code></pre>"},{"location":"how-it-works/#getting-started","title":"Getting Started","text":"<ol> <li>Create Account: Sign up at app.perms.io</li> <li>Setup Organization: Create your organization and first project</li> <li>Generate API Key: Create an API key for your application</li> <li>Define Permissions: Create permissions that match your application's actions</li> <li>Create Roles: Group permissions into meaningful roles</li> <li>Assign Permissions: Grant roles and permissions to users on resources</li> <li>Integrate: Add permission checks to your application</li> <li>Test: Verify that access control works as expected</li> </ol> <p>Ready to implement fine-grained access control? Check out our Quick Start Guide to get up and running in minutes!</p>"},{"location":"iam-basics/","title":"IAM Fundamentals","text":"<p>Identity and Access Management (IAM) is a fundamental security framework that controls who can access what resources in your application and what actions they can perform. Understanding IAM concepts is crucial for implementing secure, scalable access control systems.</p>"},{"location":"iam-basics/#what-is-iam","title":"What is IAM?","text":"<p>IAM encompasses two core security functions:</p>"},{"location":"iam-basics/#authentication","title":"Authentication","text":"<p>\"Who are you?\" - Verifying the identity of users, services, or systems - Login credentials (username/password) - Multi-factor authentication (MFA) - OAuth providers (Google, GitHub, etc.) - API keys and tokens - Biometric verification</p>"},{"location":"iam-basics/#authorization","title":"Authorization","text":"<p>\"What can you do?\" - Determining what authenticated entities are allowed to access - Permission checking - Access control policies - Resource-level restrictions - Role-based access control (RBAC)</p>"},{"location":"iam-basics/#core-iam-components","title":"Core IAM Components","text":""},{"location":"iam-basics/#1-identity-principal","title":"1. Identity (Principal)","text":"<p>An identity (also called a principal) represents an entity that can be authenticated and granted permissions. Identities include:</p>"},{"location":"iam-basics/#users","title":"Users","text":"<p>Real people with accounts in your system: <pre><code>{\n  \"id\": \"user_12345\",\n  \"email\": \"alice@company.com\",\n  \"name\": \"Alice Johnson\",\n  \"type\": \"user\"\n}\n</code></pre></p>"},{"location":"iam-basics/#service-accounts","title":"Service Accounts","text":"<p>Applications or automated systems: <pre><code>{\n  \"id\": \"service_backup_system\",\n  \"name\": \"Backup Service\",\n  \"type\": \"service_account\"\n}\n</code></pre></p>"},{"location":"iam-basics/#api-keys","title":"API Keys","text":"<p>Programmatic access tokens: <pre><code>{\n  \"id\": \"api_key_67890\",\n  \"name\": \"Mobile App API Key\",\n  \"type\": \"api_key\"\n}\n</code></pre></p>"},{"location":"iam-basics/#groupsteams","title":"Groups/Teams","text":"<p>Collections of users: <pre><code>{\n  \"id\": \"group_engineering\",\n  \"name\": \"Engineering Team\",\n  \"members\": [\"user_12345\", \"user_67890\"],\n  \"type\": \"group\"\n}\n</code></pre></p>"},{"location":"iam-basics/#2-resources","title":"2. Resources","text":"<p>Resources are the objects, data, or services you want to protect. Everything that requires access control is a resource.</p>"},{"location":"iam-basics/#physical-resources","title":"Physical Resources","text":"<ul> <li>Servers and infrastructure</li> <li>Database instances</li> <li>Storage systems</li> <li>Network devices</li> </ul>"},{"location":"iam-basics/#digital-resources","title":"Digital Resources","text":"<ul> <li>Files and documents</li> <li>Database records</li> <li>API endpoints</li> <li>Applications and services</li> </ul>"},{"location":"iam-basics/#logical-resources","title":"Logical Resources","text":"<ul> <li>Projects and workspaces</li> <li>Organizations and teams</li> <li>Workflows and processes</li> <li>Configurations and settings</li> </ul>"},{"location":"iam-basics/#resource-identification","title":"Resource Identification","text":"<p>Resources are identified using Resource URIs - hierarchical identifiers that uniquely specify each resource:</p> <pre><code>/organization/acme\n\u251c\u2500\u2500 /organization/acme/project/web-app\n\u2502   \u251c\u2500\u2500 /organization/acme/project/web-app/environment/production\n\u2502   \u251c\u2500\u2500 /organization/acme/project/web-app/environment/staging\n\u2502   \u2514\u2500\u2500 /organization/acme/project/web-app/database/users\n\u251c\u2500\u2500 /organization/acme/project/mobile-app\n\u2502   \u251c\u2500\u2500 /organization/acme/project/mobile-app/api/v1\n\u2502   \u2514\u2500\u2500 /organization/acme/project/mobile-app/api/v2\n\u2514\u2500\u2500 /organization/acme/billing\n    \u251c\u2500\u2500 /organization/acme/billing/invoices\n    \u2514\u2500\u2500 /organization/acme/billing/payments\n</code></pre>"},{"location":"iam-basics/#3-permissions","title":"3. Permissions","text":"<p>Permissions define specific actions that can be performed on resources. They represent the most granular level of access control.</p>"},{"location":"iam-basics/#action-based-permissions","title":"Action-Based Permissions","text":"<pre><code>document.read      - View document content\ndocument.write     - Create or modify documents\ndocument.delete    - Remove documents\ndocument.share     - Share documents with others\n</code></pre>"},{"location":"iam-basics/#crud-operations","title":"CRUD Operations","text":"<pre><code>create    - Add new resources\nread      - View existing resources\nupdate    - Modify existing resources\ndelete    - Remove resources\n</code></pre>"},{"location":"iam-basics/#administrative-permissions","title":"Administrative Permissions","text":"<pre><code>admin.users.create    - Create new user accounts\nadmin.users.suspend   - Suspend user accounts\nadmin.billing.view    - View billing information\nadmin.logs.access     - Access system logs\n</code></pre>"},{"location":"iam-basics/#domain-specific-permissions","title":"Domain-Specific Permissions","text":"<pre><code>deploy.staging      - Deploy to staging environment\ndeploy.production   - Deploy to production environment\ndatabase.backup     - Create database backups\nsupport.tickets     - Access support tickets\n</code></pre>"},{"location":"iam-basics/#4-roles","title":"4. Roles","text":"<p>Roles are collections of permissions that can be assigned as a group. They simplify access management by grouping related permissions together.</p>"},{"location":"iam-basics/#predefined-roles","title":"Predefined Roles","text":"<p>Viewer Role <pre><code>{\n  \"name\": \"viewer\",\n  \"description\": \"Read-only access to resources\",\n  \"permissions\": [\n    \"read\",\n    \"list\",\n    \"view\"\n  ]\n}\n</code></pre></p> <p>Editor Role <pre><code>{\n  \"name\": \"editor\", \n  \"description\": \"Can view and modify resources\",\n  \"permissions\": [\n    \"read\",\n    \"write\", \n    \"update\",\n    \"create\"\n  ]\n}\n</code></pre></p> <p>Admin Role <pre><code>{\n  \"name\": \"admin\",\n  \"description\": \"Full control over resources\",\n  \"permissions\": [\n    \"read\",\n    \"write\",\n    \"update\", \n    \"create\",\n    \"delete\",\n    \"manage\",\n    \"configure\"\n  ]\n}\n</code></pre></p>"},{"location":"iam-basics/#custom-roles","title":"Custom Roles","text":"<p>Create roles specific to your application's needs:</p> <p>Content Manager <pre><code>{\n  \"name\": \"content_manager\",\n  \"description\": \"Manages content creation and publication\",\n  \"permissions\": [\n    \"content.create\",\n    \"content.edit\",\n    \"content.publish\",\n    \"content.review\",\n    \"media.upload\"\n  ]\n}\n</code></pre></p> <p>DevOps Engineer <pre><code>{\n  \"name\": \"devops_engineer\",\n  \"description\": \"Manages infrastructure and deployments\",\n  \"permissions\": [\n    \"deploy.staging\",\n    \"deploy.production\",\n    \"infrastructure.configure\",\n    \"monitoring.access\",\n    \"logs.view\"\n  ]\n}\n</code></pre></p>"},{"location":"iam-basics/#5-policies","title":"5. Policies","text":"<p>Policies define the rules that govern access control. They specify which principals can perform which actions on which resources under what conditions.</p>"},{"location":"iam-basics/#basic-policy-structure","title":"Basic Policy Structure","text":"<pre><code>{\n  \"principal\": \"user_alice\",\n  \"resource\": \"/project/web-app/database/users\",\n  \"permissions\": [\"read\", \"write\"],\n  \"effect\": \"allow\"\n}\n</code></pre>"},{"location":"iam-basics/#conditional-policies","title":"Conditional Policies","text":"<pre><code>{\n  \"principal\": \"group_developers\",\n  \"resource\": \"/project/*/environment/staging\",\n  \"permissions\": [\"deploy\"],\n  \"effect\": \"allow\",\n  \"conditions\": {\n    \"time_of_day\": \"09:00-17:00\",\n    \"source_ip\": \"10.0.0.0/8\"\n  }\n}\n</code></pre>"},{"location":"iam-basics/#iam-models","title":"IAM Models","text":""},{"location":"iam-basics/#1-discretionary-access-control-dac","title":"1. Discretionary Access Control (DAC)","text":"<p>Resource owners control access to their resources:</p> <ul> <li>User-controlled: Individual users set permissions</li> <li>Flexible: Easy to share and delegate access</li> <li>Scalability issues: Difficult to manage at scale</li> <li>Security risks: Users may grant excessive permissions</li> </ul> <p>Example: File system permissions where file owners can set read/write permissions for other users.</p>"},{"location":"iam-basics/#2-mandatory-access-control-mac","title":"2. Mandatory Access Control (MAC)","text":"<p>System-wide policies control access:</p> <ul> <li>Centrally controlled: Administrators set all permissions</li> <li>Security focused: Strong security guarantees</li> <li>Inflexible: Difficult to adapt to changing needs</li> <li>Complex: Requires detailed security classifications</li> </ul> <p>Example: Military security systems with Top Secret, Secret, and Confidential classifications.</p>"},{"location":"iam-basics/#3-role-based-access-control-rbac","title":"3. Role-Based Access Control (RBAC)","text":"<p>Access based on user roles within the organization:</p> <ul> <li>Role-centric: Permissions assigned to roles, not individuals</li> <li>Scalable: Easy to manage large numbers of users</li> <li>Organizational alignment: Reflects real-world job functions</li> <li>Standard approach: Widely adopted in business applications</li> </ul>"},{"location":"iam-basics/#rbac-components","title":"RBAC Components","text":"<pre><code>Users \u2500\u2500\u2192 Roles \u2500\u2500\u2192 Permissions \u2500\u2500\u2192 Objects/Resources\n  \u2502                                          \n  \u2514\u2500\u2500\u2500\u2500\u2500\u2192 Sessions \u2500\u2500\u2192 Roles\n</code></pre> <p>Users \u2192 assigned to \u2192 Roles \u2192 granted \u2192 Permissions \u2192 on \u2192 Resources</p>"},{"location":"iam-basics/#rbac-example","title":"RBAC Example","text":"<pre><code>Alice (User) \u2192 Editor Role \u2192 [read, write, publish] \u2192 /blog/posts/*\nBob (User) \u2192 Viewer Role \u2192 [read] \u2192 /blog/posts/*\nCarol (User) \u2192 Admin Role \u2192 [read, write, delete, manage] \u2192 /blog/*\n</code></pre>"},{"location":"iam-basics/#4-attribute-based-access-control-abac","title":"4. Attribute-Based Access Control (ABAC)","text":"<p>Dynamic access based on attributes:</p> <ul> <li>Context-aware: Considers user, resource, and environmental attributes</li> <li>Fine-grained: Very precise access control</li> <li>Complex: Requires sophisticated policy engines</li> <li>Flexible: Adapts to complex business rules</li> </ul>"},{"location":"iam-basics/#abac-example","title":"ABAC Example","text":"<pre><code>{\n  \"policy\": \"Allow access if user is manager AND resource is in their department AND current time is business hours\",\n  \"user_attributes\": {\n    \"role\": \"manager\",\n    \"department\": \"engineering\",\n    \"clearance_level\": \"3\"\n  },\n  \"resource_attributes\": {\n    \"department\": \"engineering\", \n    \"classification\": \"internal\",\n    \"data_type\": \"source_code\"\n  },\n  \"environment_attributes\": {\n    \"time\": \"14:30\",\n    \"day_of_week\": \"Tuesday\",\n    \"location\": \"office_network\"\n  }\n}\n</code></pre>"},{"location":"iam-basics/#permission-inheritance-and-hierarchies","title":"Permission Inheritance and Hierarchies","text":""},{"location":"iam-basics/#hierarchical-resources","title":"Hierarchical Resources","text":"<p>Resources often exist in hierarchical relationships where permissions granted at higher levels automatically apply to lower levels:</p> <pre><code>/organization/acme                 \u2190 Admin permissions here\n\u251c\u2500\u2500 /organization/acme/project/web \u2190 apply to all projects\n\u2502   \u251c\u2500\u2500 /environment/staging       \u2190 and all environments\n\u2502   \u2514\u2500\u2500 /environment/production    \u2190 within those projects\n\u2514\u2500\u2500 /organization/acme/project/api\n    \u251c\u2500\u2500 /environment/staging\n    \u2514\u2500\u2500 /environment/production\n</code></pre>"},{"location":"iam-basics/#inheritance-rules","title":"Inheritance Rules","text":"<ol> <li>Explicit permissions override inherited permissions</li> <li>More specific permissions override general permissions</li> <li>Closest parent permissions take precedence</li> </ol>"},{"location":"iam-basics/#inheritance-example","title":"Inheritance Example","text":"<p>Given these permission assignments: <pre><code>[\n  {\n    \"principal\": \"alice\",\n    \"resource\": \"/organization/acme\",\n    \"permissions\": [\"read\"]\n  },\n  {\n    \"principal\": \"alice\", \n    \"resource\": \"/organization/acme/project/web\",\n    \"permissions\": [\"write\"]\n  },\n]\n</code></pre></p> <p>Alice's effective permissions: - <code>/organization/acme/*</code>: read (inherited) - <code>/organization/acme/project/web/*</code>: read + write (inherited + explicit)</p>"},{"location":"iam-basics/#best-practices","title":"Best Practices","text":""},{"location":"iam-basics/#1-principle-of-least-privilege","title":"1. Principle of Least Privilege","text":"<p>Grant the minimum permissions necessary for users to perform their job functions:</p> <pre><code>// Good: Specific permissions\n{\n  \"role\": \"content_editor\",\n  \"permissions\": [\n    \"articles.create\",\n    \"articles.edit\", \n    \"articles.publish\",\n    \"media.upload\"\n  ]\n}\n\n// Avoid: Overly broad permissions\n{\n  \"role\": \"content_editor\", \n  \"permissions\": [\n    \"admin.*\",\n    \"system.*\"\n  ]\n}\n</code></pre>"},{"location":"iam-basics/#2-role-based-organization","title":"2. Role-Based Organization","text":"<p>Design roles that mirror your organization structure:</p> <pre><code>{\n  \"engineering_roles\": [\n    \"software_engineer\",\n    \"senior_engineer\", \n    \"engineering_manager\",\n    \"principal_engineer\"\n  ],\n  \"product_roles\": [\n    \"product_manager\",\n    \"product_owner\",\n    \"product_analyst\"\n  ],\n  \"operations_roles\": [\n    \"devops_engineer\",\n    \"site_reliability_engineer\",\n    \"system_administrator\"\n  ]\n}\n</code></pre>"},{"location":"iam-basics/#3-resource-hierarchy-design","title":"3. Resource Hierarchy Design","text":"<p>Create logical resource hierarchies that support inheritance:</p> <pre><code># Good: Logical hierarchy\n/company/departments/engineering/teams/platform/projects/auth-service\n\n# Avoid: Flat structure\n/auth-service-engineering-platform-team\n</code></pre>"},{"location":"iam-basics/#4-regular-access-reviews","title":"4. Regular Access Reviews","text":"<p>Implement periodic reviews of permissions:</p> <ul> <li>Quarterly access reviews: Review all role assignments</li> <li>Project completion: Remove project-specific access</li> <li>Role changes: Update permissions when people change roles</li> <li>Offboarding: Immediately revoke all access when people leave</li> </ul>"},{"location":"iam-basics/#5-audit-and-logging","title":"5. Audit and Logging","text":"<p>Track all access control decisions:</p> <pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"principal\": \"alice@company.com\",\n  \"resource\": \"/project/web-app/database/users\",\n  \"action\": \"read\",\n  \"result\": \"allowed\",\n  \"reason\": \"role:database_reader\"\n}\n</code></pre>"},{"location":"iam-basics/#6-separation-of-duties","title":"6. Separation of Duties","text":"<p>Prevent conflicts of interest by separating incompatible functions:</p> <pre><code>// Finance roles - separate creation from approval\n{\n  \"expense_creator\": [\"expense.create\", \"expense.submit\"],\n  \"expense_approver\": [\"expense.approve\", \"expense.reject\"],\n  \"expense_payer\": [\"payment.create\", \"payment.execute\"]\n}\n\n// Development roles - separate development from production  \n{\n  \"developer\": [\"code.write\", \"deploy.staging\"],\n  \"release_manager\": [\"deploy.production\", \"rollback.production\"]\n}\n</code></pre>"},{"location":"iam-basics/#conclusion","title":"Conclusion","text":"<p>Effective IAM is critical for application security and requires careful planning and implementation. Key takeaways:</p> <ul> <li>Start simple: Begin with basic RBAC and expand as needed</li> <li>Think hierarchically: Design resource structures that support inheritance</li> <li>Follow best practices: Implement least privilege, separation of duties, and regular reviews</li> <li>Monitor continuously: Track access patterns and audit permissions regularly</li> <li>Choose the right tools: Select IAM solutions that fit your architecture and scale</li> </ul> <p>Ready to implement robust access control? Permio provides a modern, scalable IAM platform that simplifies permission management while providing enterprise-grade security. Check out our Quick Start Guide to begin implementing fine-grained access control in your applications.</p>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>Get up and running with perms.io's Resource-Specific RBAC system in minutes. This guide will walk you through setting up permissions and performing access checks.</p>"},{"location":"quickstart/#overview","title":"Overview","text":"<p>perms.io provides a complete RBAC system with: - Organisations - Top-level containers for your resources - Projects - Logical groupings within organisations  - Permissions - Individual actions (read, write, delete) - Roles - Collections of permissions - Principals - Users or entities that can be granted access</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Account at app.perms.io</li> <li>Organization, project, and API key created via the dashboard</li> <li>Basic understanding of REST APIs or gRPC</li> </ul>"},{"location":"quickstart/#step-1-setup-via-dashboard","title":"Step 1: Setup via Dashboard","text":"<p>Before using the API, complete the initial setup through the web dashboard:</p> <ol> <li>Create Your Organisation: Go to app.perms.io and create your organization</li> <li>Create a Project: Create a project within your organization (e.g., \"production\")</li> <li>Generate API Key: Create an API key for your project to use in the examples below</li> </ol>"},{"location":"quickstart/#step-2-create-permissions","title":"Step 2: Create Permissions","text":"<p>Define the actions that can be performed in your application.</p> cURLGoPython <pre><code># Create read permission\ncurl -X POST \"https://api.perms.io/permissions-service/v1/permissions\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"name\": \"document.read\",\n    \"description\": \"Allows reading documents\"\n  }'\n\n# Create write permission\ncurl -X POST \"https://api.perms.io/permissions-service/v1/permissions\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"name\": \"document.write\",\n    \"description\": \"Allows writing documents\"\n  }'\n</code></pre> <pre><code>func createPermissions(client permissionsv1.PermissionsServiceClient, ctx context.Context) ([]string, error) {\n    permissions := []struct {\n        name        string\n        description string\n    }{\n        {\"document.read\", \"Allows reading documents\"},\n        {\"document.write\", \"Allows writing documents\"},\n    }\n\n    var permissionIds []string\n\n    for _, perm := range permissions {\n        req := &amp;permissionsv1.CreatePermissionRequest{\n            ProjectName: \"production\",\n            Name:        perm.name,\n            Description: perm.description,\n        }\n\n        resp, err := client.CreatePermission(ctx, req)\n        if err != nil {\n            return nil, fmt.Errorf(\"failed to create permission %s: %v\", perm.name, err)\n        }\n\n        permissionIds = append(permissionIds, resp.Id)\n        fmt.Printf(\"Created permission: %s (ID: %s)\\n\", resp.Name, resp.Id)\n    }\n\n    return permissionIds, nil\n}\n</code></pre> <pre><code>def create_permissions():\n    channel = grpc.secure_channel('api.perms.io:443', ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    metadata = [('authorization', 'Bearer YOUR_API_KEY')]\n\n    permissions = [\n        (\"document.read\", \"Allows reading documents\"),\n        (\"document.write\", \"Allows writing documents\")\n    ]\n\n    permission_ids = []\n\n    for name, description in permissions:\n        request = permissions_service_pb2.CreatePermissionRequest(\n            project_name=\"production\",\n            name=name,\n            description=description\n        )\n\n        response = client.CreatePermission(request, metadata=metadata)\n        permission_ids.append(response.id)\n        print(f\"Created permission: {response.name} (ID: {response.id})\")\n\n    return permission_ids\n</code></pre>"},{"location":"quickstart/#step-3-create-roles","title":"Step 3: Create Roles","text":"<p>Group permissions into roles for easier management.</p> cURLGoPython <pre><code># Create editor role\ncurl -X POST \"https://api.perms.io/permissions-service/v1/roles\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"name\": \"document_editor\",\n    \"description\": \"Can read and write documents\",\n    \"permissions\": [\"PERMISSION_ID_1\", \"PERMISSION_ID_2\"]\n  }'\n</code></pre> <pre><code>func createRoles(client permissionsv1.PermissionsServiceClient, ctx context.Context, permissionIds []string) ([]string, error) {\n    roles := []struct {\n        name        string\n        description string\n        permissions []string\n    }{\n        {\n            name:        \"document_viewer\",\n            description: \"Can read documents\",\n            permissions: []string{permissionIds[0]}, // read only\n        },\n        {\n            name:        \"document_editor\",\n            description: \"Can read and write documents\",\n            permissions: []string{permissionIds[0], permissionIds[1]}, // read + write\n        },\n    }\n\n    var roleIds []string\n\n    for _, role := range roles {\n        req := &amp;permissionsv1.CreateRoleRequest{\n            ProjectName: \"production\",\n            Name:        role.name,\n            Description: role.description,\n            Permissions: role.permissions,\n        }\n\n        resp, err := client.CreateRole(ctx, req)\n        if err != nil {\n            return nil, fmt.Errorf(\"failed to create role %s: %v\", role.name, err)\n        }\n\n        roleIds = append(roleIds, resp.Id)\n        fmt.Printf(\"Created role: %s (ID: %s)\\n\", resp.Name, resp.Id)\n    }\n\n    return roleIds, nil\n}\n</code></pre> <pre><code>def create_roles(permission_ids: list[str]) -&gt; list[str]:\n    channel = grpc.secure_channel('api.perms.io:443', ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    metadata = [('authorization', 'Bearer YOUR_API_KEY')]\n\n    roles = [\n        (\"document_viewer\", \"Can read documents\", [permission_ids[0]]),\n        (\"document_editor\", \"Can read and write documents\", [permission_ids[0], permission_ids[1]]),\n    ]\n\n    role_ids = []\n\n    for name, description, permissions in roles:\n        request = permissions_service_pb2.CreateRoleRequest(\n            project_name=\"production\",\n            name=name,\n            description=description,\n            permissions=permissions\n        )\n\n        response = client.CreateRole(request, metadata=metadata)\n        role_ids.append(response.id)\n        print(f\"Created role: {response.name} (ID: {response.id})\")\n\n    return role_ids\n</code></pre>"},{"location":"quickstart/#step-4-grant-permissions-to-users","title":"Step 4: Grant Permissions to Users","text":"<p>Assign permissions and roles to users on specific resources.</p> cURLGoPython <pre><code># Grant editor role to user on specific document\ncurl -X POST \"https://api.perms.io/permissions-service/v1/permissions/assign\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"user_id\": \"user_123\",\n    \"resource_uri\": \"/documents/doc_456\",\n    \"permissions\": [],\n    \"roles\": [\"ROLE_ID\"]\n  }'\n</code></pre> <pre><code>func grantPermissions(client permissionsv1.PermissionsServiceClient, ctx context.Context, roleIds []string) error {\n    req := &amp;permissionsv1.GrantUserPermissionsAndRolesOnResourceRequest{\n        ProjectName: \"production\",\n        UserId:      \"user_123\",\n        ResourceUri: \"/documents\",\n        Permissions: []string{},\n        Roles:       []string{roleIds[0]}, // viewer role\n    }\n\n    _, err := client.GrantUserPermissionsAndRolesOnResource(ctx, req)\n    if err != nil {\n        return fmt.Errorf(\"failed to grant permissions: %v\", err)\n    }\n\n    fmt.Printf(\"Granted permissions to user_123 on /documents\\n\")\n    return nil\n}\n</code></pre> <pre><code>def grant_permissions(role_ids: list[str]):\n    channel = grpc.secure_channel('api.perms.io:443', ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    metadata = [('authorization', 'Bearer YOUR_API_KEY')]\n\n    request = permissions_service_pb2.GrantUserPermissionsAndRolesOnResourceRequest(\n        project_name=\"production\",\n        user_id=\"user_123\",\n        resource_uri=\"/documents\",\n        permissions=[],\n        roles=[role_ids[0]]  # viewer role\n    )\n\n    client.GrantUserPermissionsAndRolesOnResource(request, metadata=metadata)\n    print(\"Granted permissions to user_123 on /documents\")\n</code></pre>"},{"location":"quickstart/#step-5-check-permissions","title":"Step 5: Check Permissions","text":"<p>Verify that users have the required permissions for specific actions.</p> cURLGoPython <pre><code># Check if user can read document\ncurl -X POST \"https://api.perms.io/permissions-service/v1/permissions/check\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"principal_id\": \"user_123\",\n    \"resource_uris\": [\"/documents/doc_456\"],\n    \"permissions\": [\"document.read\"]\n  }'\n</code></pre> <pre><code>func checkPermissions(client permissionsv1.PermissionsServiceClient, ctx context.Context) error {\n    req := &amp;permissionsv1.CheckPermissionRequest{\n        ProjectName:  \"production\",\n        PrincipalId:  \"user_123\",\n        ResourceUris: []string{\"/documents/doc_456\"},\n        Permissions:  []string{\"document.read\"},\n    }\n\n    resp, err := client.Check(ctx, req)\n    if err != nil {\n        return fmt.Errorf(\"failed to check permissions: %v\", err)\n    }\n\n    if resp.Passed {\n        fmt.Printf(\"\u2705 User user_123 has required permissions\\n\")\n    } else {\n        fmt.Printf(\"\u274c User user_123 missing permissions:\\n\")\n        for _, missing := range resp.MissingPermissions {\n            fmt.Printf(\"  Resource: %s, Missing: %v\\n\", missing.ResourceUri, missing.MissingPermissions)\n        }\n    }\n\n    return nil\n}\n</code></pre> <pre><code>def check_permissions():\n    channel = grpc.secure_channel('api.perms.io:443', ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    metadata = [('authorization', 'Bearer YOUR_API_KEY')]\n\n    request = permissions_service_pb2.CheckPermissionRequest(\n        project_name=\"production\",\n        principal_id=\"user_123\",\n        resource_uris=[\"/documents/doc_456\"],\n        permissions=[\"document.read\"]\n    )\n\n    response = client.Check(request, metadata=metadata)\n\n    if response.passed:\n        print(\"\u2705 User user_123 has required permissions\")\n    else:\n        print(\"\u274c User user_123 missing permissions:\")\n        for missing in response.missing_permissions:\n            print(f\"  Resource: {missing.resource_uri}, Missing: {missing.missing_permissions}\")\n</code></pre>"},{"location":"quickstart/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that sets up a basic document management system:</p> cURLGoPython <pre><code># 1. Create permissions\ncurl -X POST \"https://api.perms.io/permissions-service/v1/permissions\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"project_name\": \"production\", \"name\": \"document.read\", \"description\": \"Read documents\"}'\n\ncurl -X POST \"https://api.perms.io/permissions-service/v1/permissions\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"project_name\": \"production\", \"name\": \"document.write\", \"description\": \"Write documents\"}'\n\n# 2. Create role\ncurl -X POST \"https://api.perms.io/permissions-service/v1/roles\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"project_name\": \"production\", \"name\": \"document_editor\", \"description\": \"Can read and write\", \"permissions\": [\"PERM_ID_1\", \"PERM_ID_2\"]}'\n\n# 3. Grant permissions\ncurl -X POST \"https://api.perms.io/permissions-service/v1/permissions/assign\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"project_name\": \"production\", \"user_id\": \"user_123\", \"resource_uri\": \"/documents\", \"roles\": [\"ROLE_ID\"]}'\n\n# 4. Check permissions\ncurl -X POST \"https://api.perms.io/permissions-service/v1/permissions/check\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"project_name\": \"production\", \"principal_id\": \"user_123\", \"resource_uris\": [\"/documents/doc_456\"], \"permissions\": [\"document.read\"]}'\n</code></pre> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/credentials\"\n    \"google.golang.org/grpc/metadata\"\n\n    permissionsv1 \"github.com/PrivateJAR/permio-go/proto/permissions/v1\"\n)\n\nfunc main() {\n    // Connect to the API\n    conn, err := grpc.Dial(\"api.perms.io:443\", grpc.WithTransportCredentials(credentials.NewTLS(nil)))\n    if err != nil {\n        log.Fatalf(\"Failed to connect: %v\", err)\n    }\n    defer conn.Close()\n\n    client := permissionsv1.NewPermissionsServiceClient(conn)\n\n    // Setup authentication context\n    ctx := metadata.AppendToOutgoingContext(context.Background(), \"authorization\", \"Bearer YOUR_API_KEY\")\n\n    // 1. Create permissions\n    permissionIds, err := createPermissions(client, ctx)\n    if err != nil {\n        log.Fatalf(\"Failed to create permissions: %v\", err)\n    }\n\n    // 2. Create roles\n    roleIds, err := createRoles(client, ctx, permissionIds)\n    if err != nil {\n        log.Fatalf(\"Failed to create roles: %v\", err)\n    }\n\n    // 3. Grant permissions\n    err = grantPermissions(client, ctx, roleIds)\n    if err != nil {\n        log.Fatalf(\"Failed to grant permissions: %v\", err)\n    }\n\n    // 4. Check permissions\n    err = checkPermissions(client, ctx)\n    if err != nil {\n        log.Fatalf(\"Failed to check permissions: %v\", err)\n    }\n\n    fmt.Printf(\"Setup complete! Your RBAC system is ready to use.\\n\")\n}\n</code></pre> <pre><code>import grpc\nfrom grpc import ssl_channel_credentials\n\nfrom proto.permissions.v1 import permissions_service_pb2\nfrom proto.permissions.v1 import permissions_service_pb2_grpc\n\ndef main():\n    # 1. Create permissions\n    permission_ids = create_permissions()\n\n    # 2. Create roles\n    role_ids = create_roles(permission_ids)\n\n    # 3. Grant permissions\n    grant_permissions(role_ids)\n\n    # 4. Check permissions\n    check_permissions()\n\n    print(\"Setup complete! Your RBAC system is ready to use.\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you have a working RBAC system, you can:</p> <ol> <li>Integrate with your application - Add permission checks to your application endpoints</li> <li>Create more complex hierarchies - Use nested resource URIs for fine-grained control</li> <li>Add more users - Invite team members to your organisation via the dashboard</li> <li>Monitor usage - Check the dashboard for usage statistics</li> <li>Implement caching - Cache permission results for better performance</li> </ol>"},{"location":"quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"quickstart/#multi-tenant-applications","title":"Multi-tenant Applications","text":"cURLGo <pre><code># Tenant-specific resources\ncurl -X POST \"https://api.perms.io/permissions-service/v1/permissions/check\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"principal_id\": \"user_123\",\n    \"resource_uris\": [\"/tenant/456/projects/789\"],\n    \"permissions\": [\"project.read\"]\n  }'\n</code></pre> <pre><code>// Tenant-specific resources\nresourceUri := fmt.Sprintf(\"/tenant/%s/projects/%s\", tenantId, projectId)\n\n// Check tenant access\ncheckResp, err := permClient.Check(ctx, &amp;permissionsv1.CheckPermissionRequest{\n    ProjectName:  \"production\",\n    PrincipalId:  userId,\n    ResourceUris: []string{resourceUri},\n    Permissions:  []string{\"project.read\"},\n})\n</code></pre>"},{"location":"quickstart/#hierarchical-permissions","title":"Hierarchical Permissions","text":"cURLGo <pre><code># Grant permissions at different levels\n# Organisation level\ncurl -X POST \"https://api.perms.io/permissions-service/v1/permissions/assign\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"project_name\": \"production\", \"user_id\": \"user_123\", \"resource_uri\": \"/organisation/123\", \"permissions\": [\"org.admin\"]}'\n\n# Project level\ncurl -X POST \"https://api.perms.io/permissions-service/v1/permissions/assign\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"project_name\": \"production\", \"user_id\": \"user_123\", \"resource_uri\": \"/organisation/123/project/456\", \"permissions\": [\"project.manage\"]}'\n</code></pre> <pre><code>// Grant permissions at different levels\n// Organisation level\ngrantPermissions(userId, \"/organisation/123\", []string{\"org.admin\"}, []string{})\n\n// Project level\ngrantPermissions(userId, \"/organisation/123/project/456\", []string{\"project.manage\"}, []string{})\n\n// Resource level\ngrantPermissions(userId, \"/organisation/123/project/456/document/789\", []string{\"document.edit\"}, []string{})\n</code></pre>"},{"location":"quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quickstart/#common-issues","title":"Common Issues","text":"<ol> <li>Permission Denied: Check that you have the required permissions for the operation</li> <li>Resource Not Found: Verify the resource URIs are correct</li> <li>Authentication Failed: Ensure your API key is valid</li> <li>Rate Limiting: Implement exponential backoff for API calls</li> </ol>"},{"location":"quickstart/#getting-help","title":"Getting Help","text":"<ul> <li>Check the API Reference for detailed endpoint documentation</li> <li>Visit app.perms.io for the web dashboard</li> <li>Review the IAM Fundamentals guide for RBAC concepts</li> </ul> <p>You're now ready to implement fine-grained access control in your applications with perms.io!</p>"},{"location":"api-reference/docs/","title":"Protocol Documentation","text":""},{"location":"api-reference/docs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>google/api/http.proto</p> <ul> <li>CustomHttpPattern</li> <li>Http</li> <li>HttpRule</li> </ul> </li> <li> <p>google/api/annotations.proto</p> <ul> <li>File-level Extensions</li> </ul> </li> <li> <p>validate/validate.proto</p> <ul> <li>AnyRules</li> <li>BoolRules</li> <li>BytesRules</li> <li>DoubleRules</li> <li>DurationRules</li> <li>EnumRules</li> <li>FieldRules</li> <li>Fixed32Rules</li> <li>Fixed64Rules</li> <li>FloatRules</li> <li>Int32Rules</li> <li>Int64Rules</li> <li>MapRules</li> <li>MessageRules</li> <li>RepeatedRules</li> <li>SFixed32Rules</li> <li>SFixed64Rules</li> <li>SInt32Rules</li> <li>SInt64Rules</li> <li>StringRules</li> <li>TimestampRules</li> <li>UInt32Rules</li> <li> <p>UInt64Rules</p> </li> <li> <p>KnownRegex</p> </li> <li> <p>File-level Extensions</p> </li> <li>File-level Extensions</li> <li>File-level Extensions</li> <li>File-level Extensions</li> </ul> </li> <li> <p>v1/organisation_service.proto</p> <ul> <li>APIKey</li> <li>ActivateBillingSubscriptionRequest</li> <li>AddEmailToMailingListRequest</li> <li>BillingCustomer</li> <li>CreateAPIKeyRequest</li> <li>CreateAPIKeyResponse</li> <li>CreateOrganisationRequest</li> <li>CreateOrganisationResponse</li> <li>CreateProjectRequest</li> <li>CreateProjectResponse</li> <li>DeleteProjectRequest</li> <li>GetCustomerActiveSubscriptionRequest</li> <li>GetCustomerActiveSubscriptionResponse</li> <li>GetCustomerBillingSessionRequest</li> <li>GetCustomerBillingSessionResponse</li> <li>GetCustomerDefaultPaymentMethodAndIntentRequest</li> <li>GetCustomerDefaultPaymentMethodAndIntentResponse</li> <li>GetOrganisationRequest</li> <li>GetOrganisationResponse</li> <li>GetProjectRequest</li> <li>GetProjectResponse</li> <li>GetProjectsForOrganisationRequest</li> <li>GetProjectsForOrganisationResponse</li> <li>GetUsersOrganisationRequest</li> <li>InvalidateAPIKeyRequest</li> <li>InviteUserToOrganisationRequest</li> <li>IsOrganisationPermittedToGrantRequest</li> <li>IsOrganisationPermittedToGrantResponse</li> <li>ListAPIKeysRequest</li> <li>ListAPIKeysResponse</li> <li>Organisation</li> <li>Project</li> <li>SetUsersOrganisationRequest</li> <li>UpdateOrganisationRequest</li> <li>UpdateOrganisationResponse</li> <li> <p>User</p> </li> <li> <p>OrganisationService</p> </li> </ul> </li> <li> <p>v1/permissions_service.proto</p> <ul> <li>Assignment</li> <li>CheckPermissionRequest</li> <li>CheckPermissionResponse</li> <li>CreatePermissionRequest</li> <li>CreateRoleRequest</li> <li>DeletePermissionRequest</li> <li>DeleteRoleRequest</li> <li>GetAllAssignmentsForPrincipalRequest</li> <li>GetAllAssignmentsForPrincipalResponse</li> <li>GetPermissionRequest</li> <li>GetRoleRequest</li> <li>GetUserPermissionsAndRolesOnResourceRequest</li> <li>GetUserPermissionsAndRolesOnResourceResponse</li> <li>GrantUserPermissionsAndRolesOnResourceRequest</li> <li>InheritedPermission</li> <li>InheritedRole</li> <li>ListPermissionsRequest</li> <li>ListPermissionsResponse</li> <li>ListPrincipalsRequest</li> <li>ListPrincipalsResponse</li> <li>ListRolesRequest</li> <li>ListRolesResponse</li> <li>MissingPermissions</li> <li>Permission</li> <li>PrincipalCountUpdatedEvent</li> <li>RevokeUserPermissionsAndRolesOnResourceRequest</li> <li>Role</li> <li>UpdatePermissionRequest</li> <li> <p>UpdateRoleRequest</p> </li> <li> <p>PermissionsService</p> </li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"api-reference/docs/#googleapihttpproto","title":"google/api/http.proto","text":""},{"location":"api-reference/docs/#customhttppattern","title":"CustomHttpPattern","text":"<p>A custom pattern is used for defining custom HTTP verb.</p> Field Type Label Description kind string The name of this custom HTTP verb. path string The path matched by this custom verb. <p></p>"},{"location":"api-reference/docs/#http","title":"Http","text":"<p>Defines the HTTP configuration for an API service. It contains a list of [HttpRule][google.api.HttpRule], each specifying the mapping of an RPC method to one or more HTTP REST API methods.</p> Field Type Label Description rules HttpRule repeated A list of HTTP configuration rules that apply to individual API methods. <p>NOTE: All service configuration rules follow \"last one wins\" order. | | fully_decode_reserved_expansion | bool |  | When set to true, URL path parameters will be fully URI-decoded except in cases of single segment matches in reserved expansion, where \"%2F\" will be left encoded.</p> <p>The default behavior is to not decode RFC 6570 reserved characters in multi segment matches. |</p> <p></p>"},{"location":"api-reference/docs/#httprule","title":"HttpRule","text":"<p>gRPC Transcoding</p> <p>gRPC Transcoding is a feature for mapping between a gRPC method and one or more HTTP REST endpoints. It allows developers to build a single API service that supports both gRPC APIs and REST APIs. Many systems, including Google APIs, Cloud Endpoints, gRPC Gateway, and Envoy proxy support this feature and use it for large scale production services.</p> <p><code>HttpRule</code> defines the schema of the gRPC/REST mapping. The mapping specifies how different portions of the gRPC request message are mapped to the URL path, URL query parameters, and HTTP request body. It also controls how the gRPC response message is mapped to the HTTP response body. <code>HttpRule</code> is typically specified as an <code>google.api.http</code> annotation on the gRPC method.</p> <p>Each mapping specifies a URL path template and an HTTP method. The path template may refer to one or more fields in the gRPC request message, as long as each field is a non-repeated field with a primitive (non-message) type. The path template controls how fields of the request message are mapped to the URL path.</p> <p>Example:</p> <pre><code>service Messaging {\n  rpc GetMessage(GetMessageRequest) returns (Message) {\n    option (google.api.http) = {\n        get: &amp;#34;/v1/{name=messages/*}&amp;#34;\n    };\n  }\n}\nmessage GetMessageRequest {\n  string name = 1; // Mapped to URL path.\n}\nmessage Message {\n  string text = 1; // The resource content.\n}\n</code></pre> <p>This enables an HTTP REST to gRPC mapping as below:</p> <ul> <li>HTTP: <code>GET /v1/messages/123456</code></li> <li>gRPC: <code>GetMessage(name: &amp;#34;messages/123456&amp;#34;)</code></li> </ul> <p>Any fields in the request message which are not bound by the path template automatically become HTTP query parameters if there is no HTTP request body. For example:</p> <pre><code>service Messaging {\n  rpc GetMessage(GetMessageRequest) returns (Message) {\n    option (google.api.http) = {\n        get:&amp;#34;/v1/messages/{message_id}&amp;#34;\n    };\n  }\n}\nmessage GetMessageRequest {\n  message SubMessage {\n    string subfield = 1;\n  }\n  string message_id = 1; // Mapped to URL path.\n  int64 revision = 2;    // Mapped to URL query parameter `revision`.\n  SubMessage sub = 3;    // Mapped to URL query parameter `sub.subfield`.\n}\n</code></pre> <p>This enables a HTTP JSON to RPC mapping as below:</p> <ul> <li>HTTP: <code>GET /v1/messages/123456?revision=2&amp;amp;sub.subfield=foo</code></li> <li>gRPC: <code>GetMessage(message_id: &amp;#34;123456&amp;#34; revision: 2 sub: SubMessage(subfield: &amp;#34;foo&amp;#34;))</code></li> </ul> <p>Note that fields which are mapped to URL query parameters must have a primitive type or a repeated primitive type or a non-repeated message type. In the case of a repeated type, the parameter can be repeated in the URL as <code>...?param=A&amp;amp;param=B</code>. In the case of a message type, each field of the message is mapped to a separate parameter, such as <code>...?foo.a=A&amp;amp;foo.b=B&amp;amp;foo.c=C</code>.</p> <p>For HTTP methods that allow a request body, the <code>body</code> field specifies the mapping. Consider a REST update method on the message resource collection:</p> <pre><code>service Messaging {\n  rpc UpdateMessage(UpdateMessageRequest) returns (Message) {\n    option (google.api.http) = {\n      patch: &amp;#34;/v1/messages/{message_id}&amp;#34;\n      body: &amp;#34;message&amp;#34;\n    };\n  }\n}\nmessage UpdateMessageRequest {\n  string message_id = 1; // mapped to the URL\n  Message message = 2;   // mapped to the body\n}\n</code></pre> <p>The following HTTP JSON to RPC mapping is enabled, where the representation of the JSON in the request body is determined by protos JSON encoding:</p> <ul> <li>HTTP: <code>PATCH /v1/messages/123456 { &amp;#34;text&amp;#34;: &amp;#34;Hi!&amp;#34; }</code></li> <li>gRPC: <code>UpdateMessage(message_id: &amp;#34;123456&amp;#34; message { text: &amp;#34;Hi!&amp;#34; })</code></li> </ul> <p>The special name <code>*</code> can be used in the body mapping to define that every field not bound by the path template should be mapped to the request body.  This enables the following alternative definition of the update method:</p> <pre><code>service Messaging {\n  rpc UpdateMessage(Message) returns (Message) {\n    option (google.api.http) = {\n      patch: &amp;#34;/v1/messages/{message_id}&amp;#34;\n      body: &amp;#34;*&amp;#34;\n    };\n  }\n}\nmessage Message {\n  string message_id = 1;\n  string text = 2;\n}\n</code></pre> <p>The following HTTP JSON to RPC mapping is enabled:</p> <ul> <li>HTTP: <code>PATCH /v1/messages/123456 { &amp;#34;text&amp;#34;: &amp;#34;Hi!&amp;#34; }</code></li> <li>gRPC: <code>UpdateMessage(message_id: &amp;#34;123456&amp;#34; text: &amp;#34;Hi!&amp;#34;)</code></li> </ul> <p>Note that when using <code>*</code> in the body mapping, it is not possible to have HTTP parameters, as all fields not bound by the path end in the body. This makes this option more rarely used in practice when defining REST APIs. The common usage of <code>*</code> is in custom methods which don't use the URL at all for transferring data.</p> <p>It is possible to define multiple HTTP methods for one RPC by using the <code>additional_bindings</code> option. Example:</p> <pre><code>service Messaging {\n  rpc GetMessage(GetMessageRequest) returns (Message) {\n    option (google.api.http) = {\n      get: &amp;#34;/v1/messages/{message_id}&amp;#34;\n      additional_bindings {\n        get: &amp;#34;/v1/users/{user_id}/messages/{message_id}&amp;#34;\n      }\n    };\n  }\n}\nmessage GetMessageRequest {\n  string message_id = 1;\n  string user_id = 2;\n}\n</code></pre> <p>This enables the following two alternative HTTP JSON to RPC mappings:</p> <ul> <li>HTTP: <code>GET /v1/messages/123456</code></li> <li> <p>gRPC: <code>GetMessage(message_id: &amp;#34;123456&amp;#34;)</code></p> </li> <li> <p>HTTP: <code>GET /v1/users/me/messages/123456</code></p> </li> <li>gRPC: <code>GetMessage(user_id: &amp;#34;me&amp;#34; message_id: &amp;#34;123456&amp;#34;)</code></li> </ul> <p>Rules for HTTP mapping</p> <ol> <li>Leaf request fields (recursive expansion nested messages in the request    message) are classified into three categories:</li> <li>Fields referred by the path template. They are passed via the URL path.</li> <li>Fields referred by the [HttpRule.body][google.api.HttpRule.body]. They    are passed via the HTTP      request body.</li> <li>All other fields are passed via the URL query parameters, and the      parameter name is the field path in the request message. A repeated      field can be represented as multiple query parameters under the same      name.</li> <li>If [HttpRule.body][google.api.HttpRule.body] is \"*\", there is no URL  query parameter, all fields     are passed via URL path and HTTP request body.</li> <li>If [HttpRule.body][google.api.HttpRule.body] is omitted, there is no HTTP  request body, all     fields are passed via URL path and URL query parameters.</li> </ol> <p>Path template syntax</p> <pre><code>Template = &amp;#34;/&amp;#34; Segments [ Verb ] ;\nSegments = Segment { &amp;#34;/&amp;#34; Segment } ;\nSegment  = &amp;#34;*&amp;#34; | &amp;#34;**&amp;#34; | LITERAL | Variable ;\nVariable = &amp;#34;{&amp;#34; FieldPath [ &amp;#34;=&amp;#34; Segments ] &amp;#34;}&amp;#34; ;\nFieldPath = IDENT { &amp;#34;.&amp;#34; IDENT } ;\nVerb     = &amp;#34;:&amp;#34; LITERAL ;\n</code></pre> <p>The syntax <code>*</code> matches a single URL path segment. The syntax <code>**</code> matches zero or more URL path segments, which must be the last part of the URL path except the <code>Verb</code>.</p> <p>The syntax <code>Variable</code> matches part of the URL path as specified by its template. A variable template must not contain other variables. If a variable matches a single path segment, its template may be omitted, e.g. <code>{var}</code> is equivalent to <code>{var=*}</code>.</p> <p>The syntax <code>LITERAL</code> matches literal text in the URL path. If the <code>LITERAL</code> contains any reserved character, such characters should be percent-encoded before the matching.</p> <p>If a variable contains exactly one path segment, such as <code>&amp;#34;{var}&amp;#34;</code> or <code>&amp;#34;{var=*}&amp;#34;</code>, when such a variable is expanded into a URL path on the client side, all characters except <code>[-_.~0-9a-zA-Z]</code> are percent-encoded. The server side does the reverse decoding. Such variables show up in the Discovery Document as <code>{var}</code>.</p> <p>If a variable contains multiple path segments, such as <code>&amp;#34;{var=foo/*}&amp;#34;</code> or <code>&amp;#34;{var=**}&amp;#34;</code>, when such a variable is expanded into a URL path on the client side, all characters except <code>[-_.~/0-9a-zA-Z]</code> are percent-encoded. The server side does the reverse decoding, except \"%2F\" and \"%2f\" are left unchanged. Such variables show up in the Discovery Document as <code>{&amp;#43;var}</code>.</p> <p>Using gRPC API Service Configuration</p> <p>gRPC API Service Configuration (service config) is a configuration language for configuring a gRPC service to become a user-facing product. The service config is simply the YAML representation of the <code>google.api.Service</code> proto message.</p> <p>As an alternative to annotating your proto file, you can configure gRPC transcoding in your service config YAML files. You do this by specifying a <code>HttpRule</code> that maps the gRPC method to a REST endpoint, achieving the same effect as the proto annotation. This can be particularly useful if you have a proto that is reused in multiple services. Note that any transcoding specified in the service config will override any matching transcoding configuration in the proto.</p> <p>The following example selects a gRPC method and applies an <code>HttpRule</code> to it:</p> <pre><code>http:\n  rules:\n    - selector: example.v1.Messaging.GetMessage\n      get: /v1/messages/{message_id}/{sub.subfield}\n</code></pre> <p>Special notes</p> <p>When gRPC Transcoding is used to map a gRPC to JSON REST endpoints, the proto to JSON conversion must follow the proto3 specification.</p> <p>While the single segment variable follows the semantics of RFC 6570 Section 3.2.2 Simple String Expansion, the multi segment variable does not follow RFC 6570 Section 3.2.3 Reserved Expansion. The reason is that the Reserved Expansion does not expand special characters like <code>?</code> and <code>#</code>, which would lead to invalid URLs. As the result, gRPC Transcoding uses a custom encoding for multi segment variables.</p> <p>The path variables must not refer to any repeated or mapped field, because client libraries are not capable of handling such variable expansion.</p> <p>The path variables must not capture the leading \"/\" character. The reason is that the most common use case \"{var}\" does not capture the leading \"/\" character. For consistency, all path variables must share the same behavior.</p> <p>Repeated message fields must not be mapped to URL query parameters, because no client library can support such complicated mapping.</p> <p>If an API needs to use a JSON array for request or response body, it can map the request or response body to a repeated field. However, some gRPC Transcoding implementations may not support this feature.</p> Field Type Label Description selector string Selects a method to which this rule applies. <p>Refer to [selector][google.api.DocumentationRule.selector] for syntax details. | | get | string |  | Maps to HTTP GET. Used for listing and getting information about resources. | | put | string |  | Maps to HTTP PUT. Used for replacing a resource. | | post | string |  | Maps to HTTP POST. Used for creating a resource or performing an action. | | delete | string |  | Maps to HTTP DELETE. Used for deleting a resource. | | patch | string |  | Maps to HTTP PATCH. Used for updating a resource. | | custom | CustomHttpPattern |  | The custom pattern is used for specifying an HTTP method that is not included in the <code>pattern</code> field, such as HEAD, or \"*\" to leave the HTTP method unspecified for this rule. The wild-card rule is useful for services that provide content to Web (HTML) clients. | | body | string |  | The name of the request field whose value is mapped to the HTTP request body, or <code>*</code> for mapping all request fields not captured by the path pattern to the HTTP body, or omitted for not having any HTTP request body.</p> <p>NOTE: the referred field must be present at the top-level of the request message type. | | response_body | string |  | Optional. The name of the response field whose value is mapped to the HTTP response body. When omitted, the entire response message will be used as the HTTP response body.</p> <p>NOTE: The referred field must be present at the top-level of the response message type. | | additional_bindings | HttpRule | repeated | Additional HTTP bindings for the selector. Nested bindings must not contain an <code>additional_bindings</code> field themselves (that is, the nesting may only be one level deep). |</p> <p></p> <p>Top</p>"},{"location":"api-reference/docs/#googleapiannotationsproto","title":"google/api/annotations.proto","text":""},{"location":"api-reference/docs/#file-level-extensions","title":"File-level Extensions","text":"Extension Type Base Number Description http HttpRule .google.protobuf.MethodOptions 72295728 See <code>HttpRule</code>. <p>Top</p>"},{"location":"api-reference/docs/#validatevalidateproto","title":"validate/validate.proto","text":""},{"location":"api-reference/docs/#anyrules","title":"AnyRules","text":"<p>AnyRules describe constraints applied exclusively to the <code>google.protobuf.Any</code> well-known type</p> Field Type Label Description required bool optional Required specifies that this field must be set in string repeated In specifies that this field's <code>type_url</code> must be equal to one of the specified values. not_in string repeated NotIn specifies that this field's <code>type_url</code> must not be equal to any of the specified values. <p></p>"},{"location":"api-reference/docs/#boolrules","title":"BoolRules","text":"<p>BoolRules describes the constraints applied to <code>bool</code> values</p> Field Type Label Description const bool optional Const specifies that this field must be exactly the specified value <p></p>"},{"location":"api-reference/docs/#bytesrules","title":"BytesRules","text":"<p>BytesRules describe the constraints applied to <code>bytes</code> values</p> Field Type Label Description const bytes optional Const specifies that this field must be exactly the specified value len uint64 optional Len specifies that this field must be the specified number of bytes min_len uint64 optional MinLen specifies that this field must be the specified number of bytes at a minimum max_len uint64 optional MaxLen specifies that this field must be the specified number of bytes at a maximum pattern string optional Pattern specifies that this field must match against the specified regular expression (RE2 syntax). The included expression should elide any delimiters. prefix bytes optional Prefix specifies that this field must have the specified bytes at the beginning of the string. suffix bytes optional Suffix specifies that this field must have the specified bytes at the end of the string. contains bytes optional Contains specifies that this field must have the specified bytes anywhere in the string. in bytes repeated In specifies that this field must be equal to one of the specified values not_in bytes repeated NotIn specifies that this field cannot be equal to one of the specified values ip bool optional Ip specifies that the field must be a valid IP (v4 or v6) address in byte format ipv4 bool optional Ipv4 specifies that the field must be a valid IPv4 address in byte format ipv6 bool optional Ipv6 specifies that the field must be a valid IPv6 address in byte format ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#doublerules","title":"DoubleRules","text":"<p>DoubleRules describes the constraints applied to <code>double</code> values</p> Field Type Label Description const double optional Const specifies that this field must be exactly the specified value lt double optional Lt specifies that this field must be less than the specified value, exclusive lte double optional Lte specifies that this field must be less than or equal to the specified value, inclusive gt double optional Gt specifies that this field must be greater than the specified value, exclusive. If the value of Gt is larger than a specified Lt or Lte, the range is reversed. gte double optional Gte specifies that this field must be greater than or equal to the specified value, inclusive. If the value of Gte is larger than a specified Lt or Lte, the range is reversed. in double repeated In specifies that this field must be equal to one of the specified values not_in double repeated NotIn specifies that this field cannot be equal to one of the specified values ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#durationrules","title":"DurationRules","text":"<p>DurationRules describe the constraints applied exclusively to the <code>google.protobuf.Duration</code> well-known type</p> Field Type Label Description required bool optional Required specifies that this field must be set const google.protobuf.Duration optional Const specifies that this field must be exactly the specified value lt google.protobuf.Duration optional Lt specifies that this field must be less than the specified value, exclusive lte google.protobuf.Duration optional Lt specifies that this field must be less than the specified value, inclusive gt google.protobuf.Duration optional Gt specifies that this field must be greater than the specified value, exclusive gte google.protobuf.Duration optional Gte specifies that this field must be greater than the specified value, inclusive in google.protobuf.Duration repeated In specifies that this field must be equal to one of the specified values not_in google.protobuf.Duration repeated NotIn specifies that this field cannot be equal to one of the specified values <p></p>"},{"location":"api-reference/docs/#enumrules","title":"EnumRules","text":"<p>EnumRules describe the constraints applied to enum values</p> Field Type Label Description const int32 optional Const specifies that this field must be exactly the specified value defined_only bool optional DefinedOnly specifies that this field must be only one of the defined values for this enum, failing on any undefined value. in int32 repeated In specifies that this field must be equal to one of the specified values not_in int32 repeated NotIn specifies that this field cannot be equal to one of the specified values <p></p>"},{"location":"api-reference/docs/#fieldrules","title":"FieldRules","text":"<p>FieldRules encapsulates the rules for each type of field. Depending on the field, the correct set should be used to ensure proper validations.</p> Field Type Label Description message MessageRules optional float FloatRules optional Scalar Field Types double DoubleRules optional int32 Int32Rules optional int64 Int64Rules optional uint32 UInt32Rules optional uint64 UInt64Rules optional sint32 SInt32Rules optional sint64 SInt64Rules optional fixed32 Fixed32Rules optional fixed64 Fixed64Rules optional sfixed32 SFixed32Rules optional sfixed64 SFixed64Rules optional bool BoolRules optional string StringRules optional bytes BytesRules optional enum EnumRules optional Complex Field Types repeated RepeatedRules optional map MapRules optional any AnyRules optional Well-Known Field Types duration DurationRules optional timestamp TimestampRules optional <p></p>"},{"location":"api-reference/docs/#fixed32rules","title":"Fixed32Rules","text":"<p>Fixed32Rules describes the constraints applied to <code>fixed32</code> values</p> Field Type Label Description const fixed32 optional Const specifies that this field must be exactly the specified value lt fixed32 optional Lt specifies that this field must be less than the specified value, exclusive lte fixed32 optional Lte specifies that this field must be less than or equal to the specified value, inclusive gt fixed32 optional Gt specifies that this field must be greater than the specified value, exclusive. If the value of Gt is larger than a specified Lt or Lte, the range is reversed. gte fixed32 optional Gte specifies that this field must be greater than or equal to the specified value, inclusive. If the value of Gte is larger than a specified Lt or Lte, the range is reversed. in fixed32 repeated In specifies that this field must be equal to one of the specified values not_in fixed32 repeated NotIn specifies that this field cannot be equal to one of the specified values ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#fixed64rules","title":"Fixed64Rules","text":"<p>Fixed64Rules describes the constraints applied to <code>fixed64</code> values</p> Field Type Label Description const fixed64 optional Const specifies that this field must be exactly the specified value lt fixed64 optional Lt specifies that this field must be less than the specified value, exclusive lte fixed64 optional Lte specifies that this field must be less than or equal to the specified value, inclusive gt fixed64 optional Gt specifies that this field must be greater than the specified value, exclusive. If the value of Gt is larger than a specified Lt or Lte, the range is reversed. gte fixed64 optional Gte specifies that this field must be greater than or equal to the specified value, inclusive. If the value of Gte is larger than a specified Lt or Lte, the range is reversed. in fixed64 repeated In specifies that this field must be equal to one of the specified values not_in fixed64 repeated NotIn specifies that this field cannot be equal to one of the specified values ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#floatrules","title":"FloatRules","text":"<p>FloatRules describes the constraints applied to <code>float</code> values</p> Field Type Label Description const float optional Const specifies that this field must be exactly the specified value lt float optional Lt specifies that this field must be less than the specified value, exclusive lte float optional Lte specifies that this field must be less than or equal to the specified value, inclusive gt float optional Gt specifies that this field must be greater than the specified value, exclusive. If the value of Gt is larger than a specified Lt or Lte, the range is reversed. gte float optional Gte specifies that this field must be greater than or equal to the specified value, inclusive. If the value of Gte is larger than a specified Lt or Lte, the range is reversed. in float repeated In specifies that this field must be equal to one of the specified values not_in float repeated NotIn specifies that this field cannot be equal to one of the specified values ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#int32rules","title":"Int32Rules","text":"<p>Int32Rules describes the constraints applied to <code>int32</code> values</p> Field Type Label Description const int32 optional Const specifies that this field must be exactly the specified value lt int32 optional Lt specifies that this field must be less than the specified value, exclusive lte int32 optional Lte specifies that this field must be less than or equal to the specified value, inclusive gt int32 optional Gt specifies that this field must be greater than the specified value, exclusive. If the value of Gt is larger than a specified Lt or Lte, the range is reversed. gte int32 optional Gte specifies that this field must be greater than or equal to the specified value, inclusive. If the value of Gte is larger than a specified Lt or Lte, the range is reversed. in int32 repeated In specifies that this field must be equal to one of the specified values not_in int32 repeated NotIn specifies that this field cannot be equal to one of the specified values ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#int64rules","title":"Int64Rules","text":"<p>Int64Rules describes the constraints applied to <code>int64</code> values</p> Field Type Label Description const int64 optional Const specifies that this field must be exactly the specified value lt int64 optional Lt specifies that this field must be less than the specified value, exclusive lte int64 optional Lte specifies that this field must be less than or equal to the specified value, inclusive gt int64 optional Gt specifies that this field must be greater than the specified value, exclusive. If the value of Gt is larger than a specified Lt or Lte, the range is reversed. gte int64 optional Gte specifies that this field must be greater than or equal to the specified value, inclusive. If the value of Gte is larger than a specified Lt or Lte, the range is reversed. in int64 repeated In specifies that this field must be equal to one of the specified values not_in int64 repeated NotIn specifies that this field cannot be equal to one of the specified values ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#maprules","title":"MapRules","text":"<p>MapRules describe the constraints applied to <code>map</code> values</p> Field Type Label Description min_pairs uint64 optional MinPairs specifies that this field must have the specified number of KVs at a minimum max_pairs uint64 optional MaxPairs specifies that this field must have the specified number of KVs at a maximum no_sparse bool optional NoSparse specifies values in this field cannot be unset. This only applies to map's with message value types. keys FieldRules optional Keys specifies the constraints to be applied to each key in the field. values FieldRules optional Values specifies the constraints to be applied to the value of each key in the field. Message values will still have their validations evaluated unless skip is specified here. ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#messagerules","title":"MessageRules","text":"<p>MessageRules describe the constraints applied to embedded message values. For message-type fields, validation is performed recursively.</p> Field Type Label Description skip bool optional Skip specifies that the validation rules of this field should not be evaluated required bool optional Required specifies that this field must be set <p></p>"},{"location":"api-reference/docs/#repeatedrules","title":"RepeatedRules","text":"<p>RepeatedRules describe the constraints applied to <code>repeated</code> values</p> Field Type Label Description min_items uint64 optional MinItems specifies that this field must have the specified number of items at a minimum max_items uint64 optional MaxItems specifies that this field must have the specified number of items at a maximum unique bool optional Unique specifies that all elements in this field must be unique. This constraint is only applicable to scalar and enum types (messages are not supported). items FieldRules optional Items specifies the constraints to be applied to each item in the field. Repeated message fields will still execute validation against each item unless skip is specified here. ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#sfixed32rules","title":"SFixed32Rules","text":"<p>SFixed32Rules describes the constraints applied to <code>sfixed32</code> values</p> Field Type Label Description const sfixed32 optional Const specifies that this field must be exactly the specified value lt sfixed32 optional Lt specifies that this field must be less than the specified value, exclusive lte sfixed32 optional Lte specifies that this field must be less than or equal to the specified value, inclusive gt sfixed32 optional Gt specifies that this field must be greater than the specified value, exclusive. If the value of Gt is larger than a specified Lt or Lte, the range is reversed. gte sfixed32 optional Gte specifies that this field must be greater than or equal to the specified value, inclusive. If the value of Gte is larger than a specified Lt or Lte, the range is reversed. in sfixed32 repeated In specifies that this field must be equal to one of the specified values not_in sfixed32 repeated NotIn specifies that this field cannot be equal to one of the specified values ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#sfixed64rules","title":"SFixed64Rules","text":"<p>SFixed64Rules describes the constraints applied to <code>sfixed64</code> values</p> Field Type Label Description const sfixed64 optional Const specifies that this field must be exactly the specified value lt sfixed64 optional Lt specifies that this field must be less than the specified value, exclusive lte sfixed64 optional Lte specifies that this field must be less than or equal to the specified value, inclusive gt sfixed64 optional Gt specifies that this field must be greater than the specified value, exclusive. If the value of Gt is larger than a specified Lt or Lte, the range is reversed. gte sfixed64 optional Gte specifies that this field must be greater than or equal to the specified value, inclusive. If the value of Gte is larger than a specified Lt or Lte, the range is reversed. in sfixed64 repeated In specifies that this field must be equal to one of the specified values not_in sfixed64 repeated NotIn specifies that this field cannot be equal to one of the specified values ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#sint32rules","title":"SInt32Rules","text":"<p>SInt32Rules describes the constraints applied to <code>sint32</code> values</p> Field Type Label Description const sint32 optional Const specifies that this field must be exactly the specified value lt sint32 optional Lt specifies that this field must be less than the specified value, exclusive lte sint32 optional Lte specifies that this field must be less than or equal to the specified value, inclusive gt sint32 optional Gt specifies that this field must be greater than the specified value, exclusive. If the value of Gt is larger than a specified Lt or Lte, the range is reversed. gte sint32 optional Gte specifies that this field must be greater than or equal to the specified value, inclusive. If the value of Gte is larger than a specified Lt or Lte, the range is reversed. in sint32 repeated In specifies that this field must be equal to one of the specified values not_in sint32 repeated NotIn specifies that this field cannot be equal to one of the specified values ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#sint64rules","title":"SInt64Rules","text":"<p>SInt64Rules describes the constraints applied to <code>sint64</code> values</p> Field Type Label Description const sint64 optional Const specifies that this field must be exactly the specified value lt sint64 optional Lt specifies that this field must be less than the specified value, exclusive lte sint64 optional Lte specifies that this field must be less than or equal to the specified value, inclusive gt sint64 optional Gt specifies that this field must be greater than the specified value, exclusive. If the value of Gt is larger than a specified Lt or Lte, the range is reversed. gte sint64 optional Gte specifies that this field must be greater than or equal to the specified value, inclusive. If the value of Gte is larger than a specified Lt or Lte, the range is reversed. in sint64 repeated In specifies that this field must be equal to one of the specified values not_in sint64 repeated NotIn specifies that this field cannot be equal to one of the specified values ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#stringrules","title":"StringRules","text":"<p>StringRules describe the constraints applied to <code>string</code> values</p> Field Type Label Description const string optional Const specifies that this field must be exactly the specified value len uint64 optional Len specifies that this field must be the specified number of characters (Unicode code points). Note that the number of characters may differ from the number of bytes in the string. min_len uint64 optional MinLen specifies that this field must be the specified number of characters (Unicode code points) at a minimum. Note that the number of characters may differ from the number of bytes in the string. max_len uint64 optional MaxLen specifies that this field must be the specified number of characters (Unicode code points) at a maximum. Note that the number of characters may differ from the number of bytes in the string. len_bytes uint64 optional LenBytes specifies that this field must be the specified number of bytes min_bytes uint64 optional MinBytes specifies that this field must be the specified number of bytes at a minimum max_bytes uint64 optional MaxBytes specifies that this field must be the specified number of bytes at a maximum pattern string optional Pattern specifies that this field must match against the specified regular expression (RE2 syntax). The included expression should elide any delimiters. prefix string optional Prefix specifies that this field must have the specified substring at the beginning of the string. suffix string optional Suffix specifies that this field must have the specified substring at the end of the string. contains string optional Contains specifies that this field must have the specified substring anywhere in the string. not_contains string optional NotContains specifies that this field cannot have the specified substring anywhere in the string. in string repeated In specifies that this field must be equal to one of the specified values not_in string repeated NotIn specifies that this field cannot be equal to one of the specified values email bool optional Email specifies that the field must be a valid email address as defined by RFC 5322 hostname bool optional Hostname specifies that the field must be a valid hostname as defined by RFC 1034. This constraint does not support internationalized domain names (IDNs). ip bool optional Ip specifies that the field must be a valid IP (v4 or v6) address. Valid IPv6 addresses should not include surrounding square brackets. ipv4 bool optional Ipv4 specifies that the field must be a valid IPv4 address. ipv6 bool optional Ipv6 specifies that the field must be a valid IPv6 address. Valid IPv6 addresses should not include surrounding square brackets. uri bool optional Uri specifies that the field must be a valid, absolute URI as defined by RFC 3986 uri_ref bool optional UriRef specifies that the field must be a valid URI as defined by RFC 3986 and may be relative or absolute. address bool optional Address specifies that the field must be either a valid hostname as defined by RFC 1034 (which does not support internationalized domain names or IDNs), or it can be a valid IP (v4 or v6). uuid bool optional Uuid specifies that the field must be a valid UUID as defined by RFC 4122 well_known_regex KnownRegex optional WellKnownRegex specifies a common well known pattern defined as a regex. strict bool optional This applies to regexes HTTP_HEADER_NAME and HTTP_HEADER_VALUE to enable strict header validation. By default, this is true, and HTTP header validations are RFC-compliant. Setting to false will enable a looser validations that only disallows \\r\\n\\0 characters, which can be used to bypass header matching rules. Default: true ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#timestamprules","title":"TimestampRules","text":"<p>TimestampRules describe the constraints applied exclusively to the <code>google.protobuf.Timestamp</code> well-known type</p> Field Type Label Description required bool optional Required specifies that this field must be set const google.protobuf.Timestamp optional Const specifies that this field must be exactly the specified value lt google.protobuf.Timestamp optional Lt specifies that this field must be less than the specified value, exclusive lte google.protobuf.Timestamp optional Lte specifies that this field must be less than the specified value, inclusive gt google.protobuf.Timestamp optional Gt specifies that this field must be greater than the specified value, exclusive gte google.protobuf.Timestamp optional Gte specifies that this field must be greater than the specified value, inclusive lt_now bool optional LtNow specifies that this must be less than the current time. LtNow can only be used with the Within rule. gt_now bool optional GtNow specifies that this must be greater than the current time. GtNow can only be used with the Within rule. within google.protobuf.Duration optional Within specifies that this field must be within this duration of the current time. This constraint can be used alone or with the LtNow and GtNow rules. <p></p>"},{"location":"api-reference/docs/#uint32rules","title":"UInt32Rules","text":"<p>UInt32Rules describes the constraints applied to <code>uint32</code> values</p> Field Type Label Description const uint32 optional Const specifies that this field must be exactly the specified value lt uint32 optional Lt specifies that this field must be less than the specified value, exclusive lte uint32 optional Lte specifies that this field must be less than or equal to the specified value, inclusive gt uint32 optional Gt specifies that this field must be greater than the specified value, exclusive. If the value of Gt is larger than a specified Lt or Lte, the range is reversed. gte uint32 optional Gte specifies that this field must be greater than or equal to the specified value, inclusive. If the value of Gte is larger than a specified Lt or Lte, the range is reversed. in uint32 repeated In specifies that this field must be equal to one of the specified values not_in uint32 repeated NotIn specifies that this field cannot be equal to one of the specified values ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#uint64rules","title":"UInt64Rules","text":"<p>UInt64Rules describes the constraints applied to <code>uint64</code> values</p> Field Type Label Description const uint64 optional Const specifies that this field must be exactly the specified value lt uint64 optional Lt specifies that this field must be less than the specified value, exclusive lte uint64 optional Lte specifies that this field must be less than or equal to the specified value, inclusive gt uint64 optional Gt specifies that this field must be greater than the specified value, exclusive. If the value of Gt is larger than a specified Lt or Lte, the range is reversed. gte uint64 optional Gte specifies that this field must be greater than or equal to the specified value, inclusive. If the value of Gte is larger than a specified Lt or Lte, the range is reversed. in uint64 repeated In specifies that this field must be equal to one of the specified values not_in uint64 repeated NotIn specifies that this field cannot be equal to one of the specified values ignore_empty bool optional IgnoreEmpty specifies that the validation rules of this field should be evaluated only if the field is not empty <p></p>"},{"location":"api-reference/docs/#knownregex","title":"KnownRegex","text":"<p>WellKnownRegex contain some well-known patterns.</p> Name Number Description UNKNOWN 0 HTTP_HEADER_NAME 1 HTTP header name as defined by RFC 7230. HTTP_HEADER_VALUE 2 HTTP header value as defined by RFC 7230. <p></p>"},{"location":"api-reference/docs/#file-level-extensions_1","title":"File-level Extensions","text":"Extension Type Base Number Description rules FieldRules .google.protobuf.FieldOptions 1071 Rules specify the validations to be performed on this field. By default, no validation is performed against a field. disabled bool .google.protobuf.MessageOptions 1071 Disabled nullifies any validation rules for this message, including any message fields associated with it that do support validation. ignored bool .google.protobuf.MessageOptions 1072 Ignore skips generation of validation methods for this message. required bool .google.protobuf.OneofOptions 1071 Required ensures that exactly one the field options in a oneof is set; validation fails if no fields in the oneof are set. <p>Top</p>"},{"location":"api-reference/docs/#v1organisation_serviceproto","title":"v1/organisation_service.proto","text":""},{"location":"api-reference/docs/#apikey","title":"APIKey","text":"Field Type Label Description id string name string key string created_at google.protobuf.Timestamp invalidated bool"},{"location":"api-reference/docs/#activatebillingsubscriptionrequest","title":"ActivateBillingSubscriptionRequest","text":"Field Type Label Description organisation_id string price_id string"},{"location":"api-reference/docs/#addemailtomailinglistrequest","title":"AddEmailToMailingListRequest","text":"Field Type Label Description email string"},{"location":"api-reference/docs/#billingcustomer","title":"BillingCustomer","text":"Field Type Label Description id string organisation_id string name string email string"},{"location":"api-reference/docs/#createapikeyrequest","title":"CreateAPIKeyRequest","text":"Field Type Label Description organisation_id string project_name string project_name is the name of the project that the api key should be created in name string"},{"location":"api-reference/docs/#createapikeyresponse","title":"CreateAPIKeyResponse","text":"Field Type Label Description api_key APIKey"},{"location":"api-reference/docs/#createorganisationrequest","title":"CreateOrganisationRequest","text":"Field Type Label Description name string user_id string user_id is the user that created the organisation and will be added as an admin"},{"location":"api-reference/docs/#createorganisationresponse","title":"CreateOrganisationResponse","text":"Field Type Label Description organisation Organisation"},{"location":"api-reference/docs/#createprojectrequest","title":"CreateProjectRequest","text":"Field Type Label Description organisation_id string organisation_id is the id of the organisation name string name is the name of the new project"},{"location":"api-reference/docs/#createprojectresponse","title":"CreateProjectResponse","text":"Field Type Label Description project Project"},{"location":"api-reference/docs/#deleteprojectrequest","title":"DeleteProjectRequest","text":"Field Type Label Description organisation_id string project_name string"},{"location":"api-reference/docs/#getcustomeractivesubscriptionrequest","title":"GetCustomerActiveSubscriptionRequest","text":"Field Type Label Description organisation_id string"},{"location":"api-reference/docs/#getcustomeractivesubscriptionresponse","title":"GetCustomerActiveSubscriptionResponse","text":"Field Type Label Description active_subscription_id string optional active_subscription_id is the id of the active subscription for the customer. It is optional as the customer may not have an active subscription. active_price_id string optional active_price_id is the id of the active price for the customer. It is optional as the customer may not have an active subscription."},{"location":"api-reference/docs/#getcustomerbillingsessionrequest","title":"GetCustomerBillingSessionRequest","text":"Field Type Label Description organisation_id string"},{"location":"api-reference/docs/#getcustomerbillingsessionresponse","title":"GetCustomerBillingSessionResponse","text":"Field Type Label Description session_secret string"},{"location":"api-reference/docs/#getcustomerdefaultpaymentmethodandintentrequest","title":"GetCustomerDefaultPaymentMethodAndIntentRequest","text":"Field Type Label Description organisation_id string"},{"location":"api-reference/docs/#getcustomerdefaultpaymentmethodandintentresponse","title":"GetCustomerDefaultPaymentMethodAndIntentResponse","text":"Field Type Label Description default_payment_method_id string optional default_payment_method_id is the id of the default payment method if it exists default_payment_method_intent string optional default_payment_method_intent is the id of the payment intent for the default payment method if it exists"},{"location":"api-reference/docs/#getorganisationrequest","title":"GetOrganisationRequest","text":"Field Type Label Description id string"},{"location":"api-reference/docs/#getorganisationresponse","title":"GetOrganisationResponse","text":"Field Type Label Description organisation Organisation"},{"location":"api-reference/docs/#getprojectrequest","title":"GetProjectRequest","text":"Field Type Label Description organisation_id string project_name string"},{"location":"api-reference/docs/#getprojectresponse","title":"GetProjectResponse","text":"Field Type Label Description project Project"},{"location":"api-reference/docs/#getprojectsfororganisationrequest","title":"GetProjectsForOrganisationRequest","text":"Field Type Label Description organisation_id string"},{"location":"api-reference/docs/#getprojectsfororganisationresponse","title":"GetProjectsForOrganisationResponse","text":"Field Type Label Description projects Project repeated"},{"location":"api-reference/docs/#getusersorganisationrequest","title":"GetUsersOrganisationRequest","text":"Field Type Label Description user_id string"},{"location":"api-reference/docs/#invalidateapikeyrequest","title":"InvalidateAPIKeyRequest","text":"Field Type Label Description organisation_id string project_name string project_name is the name of the project that the api key belongs to id string"},{"location":"api-reference/docs/#inviteusertoorganisationrequest","title":"InviteUserToOrganisationRequest","text":"Field Type Label Description organisation_id string email string"},{"location":"api-reference/docs/#isorganisationpermittedtograntrequest","title":"IsOrganisationPermittedToGrantRequest","text":"Field Type Label Description organisation_id string"},{"location":"api-reference/docs/#isorganisationpermittedtograntresponse","title":"IsOrganisationPermittedToGrantResponse","text":"Field Type Label Description permitted bool"},{"location":"api-reference/docs/#listapikeysrequest","title":"ListAPIKeysRequest","text":"Field Type Label Description organisation_id string project_name string project_name is the name of the project to list the api keys for"},{"location":"api-reference/docs/#listapikeysresponse","title":"ListAPIKeysResponse","text":"Field Type Label Description api_keys APIKey repeated"},{"location":"api-reference/docs/#organisation","title":"Organisation","text":"Field Type Label Description id string name string users User repeated created_at google.protobuf.Timestamp updated_at google.protobuf.Timestamp billing_customer BillingCustomer"},{"location":"api-reference/docs/#project","title":"Project","text":"Field Type Label Description organisation_id string name string created_at google.protobuf.Timestamp"},{"location":"api-reference/docs/#setusersorganisationrequest","title":"SetUsersOrganisationRequest","text":"Field Type Label Description id string user_id string email string"},{"location":"api-reference/docs/#updateorganisationrequest","title":"UpdateOrganisationRequest","text":"Field Type Label Description id string name string"},{"location":"api-reference/docs/#updateorganisationresponse","title":"UpdateOrganisationResponse","text":"Field Type Label Description organisation Organisation"},{"location":"api-reference/docs/#user","title":"User","text":"Field Type Label Description id string email string"},{"location":"api-reference/docs/#organisationservice","title":"OrganisationService","text":"Method Name Request Type Response Type Description CreateOrganisation CreateOrganisationRequest CreateOrganisationResponse GetOrganisation GetOrganisationRequest GetOrganisationResponse UpdateOrganisation UpdateOrganisationRequest UpdateOrganisationResponse UpdateOrganisation updates the provided organisation. Required Permissions: - organisation.update on /organisation/{organisation_id} SetUsersOrganisation SetUsersOrganisationRequest .google.protobuf.Empty SetUsersOrganisation sets the provided users organisation. Required Permissions: - user.organisation.set on /user/{user_id} InviteUserToOrganisation InviteUserToOrganisationRequest .google.protobuf.Empty GetUsersOrganisation GetUsersOrganisationRequest GetOrganisationResponse GetUsersOrganisation returns the organisation for the user. Required Permissions: - user.organisation.get on /user/{user_id} CreateAPIKey CreateAPIKeyRequest CreateAPIKeyResponse ListAPIKeys ListAPIKeysRequest ListAPIKeysResponse ListAPIKeys returns a list of apiKeys for an organisation. Required Permissions: - apiKeys.list on /organisation/{organisation_id} InvalidateAPIKey InvalidateAPIKeyRequest .google.protobuf.Empty CreateProject CreateProjectRequest CreateProjectResponse SetUniquePrincipalCountForOrganisation is an internal method to set the unique principal count for an organisation. rpc SetUniquePrincipalCountForOrganisation(permissions_service.v1.PrincipalCountUpdatedEvent) returns (google.protobuf.Empty) { option (google.api.http) = { post: \"/organisation-service/v1/organisation/unique-principal-count\" body: \"*\" }; } CreateProject creates a new project for an organisation. Required Permissions: - project.create on /organisation/{organisation_id} GetProject GetProjectRequest GetProjectResponse GetProject returns the project given the organisation and project id. Required Permissions: - project.get on /organisation/{organisation_id}/project/{project_name} GetProjectsForOrganisation GetProjectsForOrganisationRequest GetProjectsForOrganisationResponse GetProjectsForOrganisation returns the project given the organisation and project id. Required Permissions: - project.get on /organisation/{organisation_id} DeleteProject DeleteProjectRequest .google.protobuf.Empty DeleteProject deletes the project for the organisation. Required Permissions: - project.delete on /organisation/{organisation_id}/project/{project_name} GetCustomerBillingSession GetCustomerBillingSessionRequest GetCustomerBillingSessionResponse GetCustomerBillingSession is an internal method and returns a new billing session for the customer to change plan configurations. Required Permissions: - billing.manage on /organisation/{organisation_id} GetCustomerActiveSubscription GetCustomerActiveSubscriptionRequest GetCustomerActiveSubscriptionResponse GetCustomerActiveSubscription is an internal method and returns the active subscription for the customer. Required Permissions: - billing.manage on /organisation/{organisation_id} GetCustomerDefaultPaymentMethodAndIntent GetCustomerDefaultPaymentMethodAndIntentRequest GetCustomerDefaultPaymentMethodAndIntentResponse GetCustomerDefaultPaymentMethodAndIntent is an internal method which returns the payment method and intent for the customer. Required Permissions: - billing.manage on /organisation/{organisation_id} ActivateBillingSubscription ActivateBillingSubscriptionRequest .google.protobuf.Empty ActivateBillingSubscription is an internal method to activate a billing subscription for the customer. Required Permissions: - billing.manage on /organisation/{organisation_id} IsOrganisationPermittedToGrant IsOrganisationPermittedToGrantRequest IsOrganisationPermittedToGrantResponse IsOrganisationPermittedToGrant is an internal method to check if the organisation can grant more principals. Required Permissions: - organisation.grant.check.permitted on /organisation/{organisation_id} AddEmailToMailingList AddEmailToMailingListRequest .google.protobuf.Empty <p>Top</p>"},{"location":"api-reference/docs/#v1permissions_serviceproto","title":"v1/permissions_service.proto","text":""},{"location":"api-reference/docs/#assignment","title":"Assignment","text":"<p>an Assignment is a set of permissions and roles assigned to a principal on a resource.</p> Field Type Label Description resource_uri string ResourceURI is the URI of the resource to which the principal is assigned permissions. permissions Permission repeated Permissions is a list of permissions that the principal has. roles Role repeated Roles is a list of roles that the principal has. <p></p>"},{"location":"api-reference/docs/#checkpermissionrequest","title":"CheckPermissionRequest","text":"Field Type Label Description project_name string project_name is the name of the project to check permissions in. principal_id string PrincipalID is the unique identifier of the principal. resource_uris string repeated ResourceURIs is a list of URIs of the resources to check. permissions string repeated Permissions is a list of permission names that the principal should have."},{"location":"api-reference/docs/#checkpermissionresponse","title":"CheckPermissionResponse","text":"Field Type Label Description passed bool passed is true if the principal has all of the specified permissions on the specified resources. missing_permissions MissingPermissions repeated missing_permissions is a list of resources and the permissions that the principal does not have on them."},{"location":"api-reference/docs/#createpermissionrequest","title":"CreatePermissionRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the permission will belong to. name string Name is the name of the permission. description string Description is the description of the permission."},{"location":"api-reference/docs/#createrolerequest","title":"CreateRoleRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the role belongs to. name string Name is the name of the role. description string Description is the description of the role. permissions string repeated Permissions is a list of permission IDs that the role has."},{"location":"api-reference/docs/#deletepermissionrequest","title":"DeletePermissionRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the permission belongs to. id string ID is the unique identifier of the permission."},{"location":"api-reference/docs/#deleterolerequest","title":"DeleteRoleRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the role belongs to. id string ID is the unique identifier of the role."},{"location":"api-reference/docs/#getallassignmentsforprincipalrequest","title":"GetAllAssignmentsForPrincipalRequest","text":"<p>GetAllAssignmentsForPrincipalRequest is the request to get all assignments for a principal.</p> Field Type Label Description project_name string project_name is the name of the project that principal belongs to. principal_id string PrincipalID is the unique identifier of the principal. <p></p>"},{"location":"api-reference/docs/#getallassignmentsforprincipalresponse","title":"GetAllAssignmentsForPrincipalResponse","text":"<p>GetAllAssignmentsForPrincipalResponse is the response to the GetAllAssignmentsForPrincipal request.</p> Field Type Label Description assignments Assignment repeated Assignments is a list of assignments for the principal. <p></p>"},{"location":"api-reference/docs/#getpermissionrequest","title":"GetPermissionRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the permission belongs to. id string ID is the unique identifier of the permission."},{"location":"api-reference/docs/#getrolerequest","title":"GetRoleRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the role belongs to. id string ID is the unique identifier of the role."},{"location":"api-reference/docs/#getuserpermissionsandrolesonresourcerequest","title":"GetUserPermissionsAndRolesOnResourceRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the grant will belong to. user_id string UserID is the unique identifier of the user. resource_uri string ResourceURI is the URI of the resource to which the user is being assigned permissions."},{"location":"api-reference/docs/#getuserpermissionsandrolesonresourceresponse","title":"GetUserPermissionsAndRolesOnResourceResponse","text":"Field Type Label Description project_name string user_id string UserID is the unique identifier of the user. resource_uri string ResourceURI is the URI of the resource to which the user is being assigned permissions. permissions string repeated Permissions is a list of permission IDs that should be assigned to the user. roles string repeated Roles is a list of role IDs that should be assigned to the user."},{"location":"api-reference/docs/#grantuserpermissionsandrolesonresourcerequest","title":"GrantUserPermissionsAndRolesOnResourceRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the grant will belong to. user_id string UserID is the unique identifier of the user. resource_uri string ResourceURI is the URI of the resource to which the user is being assigned permissions. permissions string repeated Permissions is a list of permission IDs that should be assigned to the user. roles string repeated Roles is a list of role IDs that should be assigned to the user."},{"location":"api-reference/docs/#inheritedpermission","title":"InheritedPermission","text":"<p>an InheritedPermission is a permission that a principal has inherited from a role.</p> Field Type Label Description permission Permission inherited_from string <p></p>"},{"location":"api-reference/docs/#inheritedrole","title":"InheritedRole","text":"<p>an InheritedRole is a role that a principal has inherited.</p> Field Type Label Description role Role inherited_from string <p></p>"},{"location":"api-reference/docs/#listpermissionsrequest","title":"ListPermissionsRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the permissions belong to."},{"location":"api-reference/docs/#listpermissionsresponse","title":"ListPermissionsResponse","text":"Field Type Label Description permissions Permission repeated"},{"location":"api-reference/docs/#listprincipalsrequest","title":"ListPrincipalsRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the principals belong to."},{"location":"api-reference/docs/#listprincipalsresponse","title":"ListPrincipalsResponse","text":"<p>ListPrincipalsResponse is the response to the ListPrincipals request.</p> Field Type Label Description principals string repeated <p></p>"},{"location":"api-reference/docs/#listrolesrequest","title":"ListRolesRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the roles belong to."},{"location":"api-reference/docs/#listrolesresponse","title":"ListRolesResponse","text":"Field Type Label Description roles Role repeated"},{"location":"api-reference/docs/#missingpermissions","title":"MissingPermissions","text":"Field Type Label Description resource_uri string missing_permissions string repeated"},{"location":"api-reference/docs/#permission","title":"Permission","text":"<p>a Permission identifies an action that can be performed on a resource.</p> Field Type Label Description id string ID is the unique identifier of the permission. organisation_id string OrganisationID is the unique identifier of the organisation that owns the permission. name string Name is the name of the permission. description string Description is the description of the permission. project_name string project_name is the name of the project that the permission belongs to. <p></p>"},{"location":"api-reference/docs/#principalcountupdatedevent","title":"PrincipalCountUpdatedEvent","text":"<p>PrincipalCountUpdatedEvent is an event that is published when the number of unique principals in an organisation is updated.</p> Field Type Label Description organisation_id string OrganisationID is the unique identifier of the organisation that the principal count was updated for. unique_principal_count int64 UniquePrincipalCount is the new number of unique principals in the organisation. <p></p>"},{"location":"api-reference/docs/#revokeuserpermissionsandrolesonresourcerequest","title":"RevokeUserPermissionsAndRolesOnResourceRequest","text":"Field Type Label Description project_name string project_name is the name of the project that grant belongs to. user_id string UserID is the unique identifier of the user. resource_uri string ResourceURI is the URI of the resource from which the user's permissions should be revoked. permissions string repeated Permissions is a list of permission IDs that should be revoked from the user. roles string repeated Roles is a list of role IDs that should be revoked from the user."},{"location":"api-reference/docs/#role","title":"Role","text":"<p>a Role is a collection of permissions.</p> Field Type Label Description id string ID is the unique identifier of the role. organisation_id string OrganisationID is the unique identifier of the organisation that owns the role. name string Name is the name of the role. description string Description is the description of the role. permissions Permission repeated Permissions is a list of permissions that the role contains. project_name string project_name is the name of the project that the role belongs to. <p></p>"},{"location":"api-reference/docs/#updatepermissionrequest","title":"UpdatePermissionRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the permission belongs to. id string ID is the unique identifier of the permission. name string Name is the name of the permission. description string Description is the description of the permission."},{"location":"api-reference/docs/#updaterolerequest","title":"UpdateRoleRequest","text":"Field Type Label Description project_name string project_name is the name of the project that the role belongs to. id string ID is the unique identifier of the role. name string Name is the name of the role. description string Description is the description of the role. permissions string repeated Permissions is a list of permission IDs that the role has."},{"location":"api-reference/docs/#permissionsservice","title":"PermissionsService","text":"Method Name Request Type Response Type Description CreatePermission CreatePermissionRequest Permission CreatePermission creates a new permission. It is idempotent and will update the permission if it already exists. Required Permissions: - permission.create on /organisation/{organisation_id} GetPermission GetPermissionRequest Permission GetPermission returns a permission by ID. Required Permissions: - permission.get on /organisation/{organisation_id}/permission/{id} UpdatePermission UpdatePermissionRequest Permission UpdatePermission updates a permission. It will return not found if the permission does not exist. Required Permissions: - permission.update on /organisation/{organisation_id}/permission/{id} DeletePermission DeletePermissionRequest .google.protobuf.Empty DeletePermission deletes a permission. It is idempotent and will return ok whether the permission existed or not. Required Permissions: - permission.delete on /organisation/{organisation_id}/permission/{id} ListPermissions ListPermissionsRequest ListPermissionsResponse ListPermissions returns a list of permissions. Required Permissions: - permission.list on /organisation/{organisation_id} CreateRole CreateRoleRequest Role CreateRole creates a new role. It is idempotent and will update the role if it already exists. Required Permissions: - role.create on /organisation/{organisation_id} - permission.get on /organisation/{organisation_id}/permission/{permission_id} for each permission in the role GetRole GetRoleRequest Role GetRole returns a role by ID. Required Permissions: - role.get on /organisation/{organisation_id}/role/{id} UpdateRole UpdateRoleRequest Role UpdateRole updates a role. It will return not found if the role does not exist. Required Permissions: - role.update on /organisation/{organisation_id}/role/{id} DeleteRole DeleteRoleRequest .google.protobuf.Empty DeleteRole deletes a role. It is idempotent and will return ok whether the role existed or not. Required Permissions: - role.delete on /organisation/{organisation_id}/role/{id} ListRoles ListRolesRequest ListRolesResponse ListRoles returns a list of roles. Required Permissions: - role.list on /organisation/{organisation_id} GrantUserPermissionsAndRolesOnResource GrantUserPermissionsAndRolesOnResourceRequest .google.protobuf.Empty GrantUserPermissionsAndRolesOnResource assigns permissions and roles to a user on a resource. It is additive and will not remove existing permissions or roles. Required Permissions: - permission.get on /organisation/{organisation_id}/permission/{permission_id} for each permission - role.get on /organisation/{organisation_id}/role/{role_id} for each role - principal.assignment.create on /organisation/{organisation_id}/principal/{user_id} RevokeUserPermissionsAndRolesOnResource RevokeUserPermissionsAndRolesOnResourceRequest .google.protobuf.Empty RevokeUserPermissionsAndRolesOnResource revokes permissions and roles from a user on a resource. Required Permissions: - principal.assignment.delete on RevokeUserPermissionsAndRolesOnResourceRequest.resource_uri GetUserPermissionsAndRolesOnResource GetUserPermissionsAndRolesOnResourceRequest GetUserPermissionsAndRolesOnResourceResponse GetUserPermissionsAndRolesOnResource returns the permissions and roles assigned to a user on a resource. Required Permissions: - principal.assignment.get on GetUserPermissionsAndRolesOnResourceRequest.resource_uri ListPrincipals ListPrincipalsRequest ListPrincipalsResponse ListPrincipals returns a list of principals. Required Permissions: - principal.list on /organisation/{organisation_id} GetAllAssignmentsForPrincipal GetAllAssignmentsForPrincipalRequest GetAllAssignmentsForPrincipalResponse GetAllAssignmentsForPrincipal returns all assignments for a principal within an organisation. Required Permissions: - principal.assignment.list on /organisation/{organisation_id}/principal/{principal_id} Check CheckPermissionRequest CheckPermissionResponse Check checks if a principal has the specified permissions on the specified resources"},{"location":"api-reference/docs/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"api-reference/organizations/","title":"Organizations &amp; Projects","text":"<p>Learn about the organizational structure in perms.io and how to work with your existing setup.</p>"},{"location":"api-reference/organizations/#overview","title":"Overview","text":"<p>Your perms.io setup is built around organizations as the top-level container for all resources. Within an organization, you can have projects to logically separate different applications or environments.</p>"},{"location":"api-reference/organizations/#key-concepts","title":"Key Concepts","text":"<ul> <li>Organization: The primary container for all resources</li> <li>Project: A logical grouping within an organization (e.g., \"production\", \"staging\")</li> <li>User: Members of an organization with various roles and permissions</li> <li>API Key: Programmatic access credentials scoped to a specific project</li> </ul>"},{"location":"api-reference/organizations/#authentication","title":"Authentication","text":"<p>All API endpoints require authentication via: - Bearer Token: For user-based authentication - API Key: For programmatic access (format: <code>Bearer pk_&lt;key&gt;</code>)</p>"},{"location":"api-reference/organizations/#base-url","title":"Base URL","text":"<pre><code>https://api.perms.io/organisation-service/v1\n</code></pre>"},{"location":"api-reference/organizations/#organization-management","title":"Organization Management","text":"<p>Organizations are created and managed through the dashboard. Once created, you can work with your organization's data through the API.</p>"},{"location":"api-reference/organizations/#get-organization","title":"Get Organization","text":"<p>Retrieves details of a specific organisation.</p> cURLGoRustPythonJavaTypeScript <pre><code>curl -X GET \"https://api.perms.io/organisation-service/v1/organisation/{id}\" \\\n  -H \"Authorization: Bearer YOUR_TOKEN\"\n</code></pre> <pre><code>func getOrganisation(client organisationv1.OrganisationServiceClient, orgId string) {\n    req := &amp;organisationv1.GetOrganisationRequest{\n        Id: orgId,\n    }\n\n    resp, err := client.GetOrganisation(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to get organisation: %v\", err)\n    }\n\n    log.Printf(\"Organisation: %s (%s)\", resp.Organisation.Name, resp.Organisation.Id)\n}\n</code></pre> <pre><code>async fn get_organisation(client: &amp;mut OrganisationServiceClient&lt;Channel&gt;, org_id: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(GetOrganisationRequest {\n        id: org_id.to_string(),\n    });\n\n    let response = client.get_organisation(request).await?;\n    let org = response.get_ref().organisation.as_ref().unwrap();\n    println!(\"Organisation: {} ({})\", org.name, org.id);\n\n    Ok(())\n}\n</code></pre> <pre><code>def get_organisation(org_id: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = organisation_service_pb2_grpc.OrganisationServiceStub(channel)\n\n    request = organisation_service_pb2.GetOrganisationRequest(id=org_id)\n    response = client.GetOrganisation(request)\n\n    print(f\"Organisation: {response.organisation.name} ({response.organisation.id})\")\n</code></pre> <pre><code>public void getOrganisation(String orgId) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    OrganisationServiceGrpc.OrganisationServiceBlockingStub client = \n            OrganisationServiceGrpc.newBlockingStub(channel);\n\n    GetOrganisationRequest request = GetOrganisationRequest.newBuilder()\n            .setId(orgId)\n            .build();\n\n    GetOrganisationResponse response = client.getOrganisation(request);\n    System.out.println(\"Organisation: \" + response.getOrganisation().getName() + \n                      \" (\" + response.getOrganisation().getId() + \")\");\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface GetOrganisationRequest {\n    id: string;\n}\n\nfunction getOrganisation(orgId: string): void {\n    const request: GetOrganisationRequest = {\n        id: orgId\n    };\n\n    client.GetOrganisation(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Organisation: ${response.organisation.name} (${response.organisation.id})`);\n    });\n}\n</code></pre>"},{"location":"api-reference/organizations/#project-management","title":"Project Management","text":"<p>Projects are created and managed through the dashboard. Use the API to work with your existing projects.</p>"},{"location":"api-reference/organizations/#get-project","title":"Get Project","text":"<p>Retrieves details of a specific project. Requires <code>project.get</code> permission.</p> cURL <pre><code>curl -X GET \"https://api.perms.io/organisation-service/v1/organisation/{organisation_id}/project?project_name={project_name}\" \\\n  -H \"Authorization: Bearer YOUR_TOKEN\"\n</code></pre>"},{"location":"api-reference/organizations/#list-projects","title":"List Projects","text":"<p>Lists all projects within an organisation. Requires <code>project.get</code> permission.</p> cURLGoRustPythonJavaTypeScript <pre><code>curl -X GET \"https://api.perms.io/organisation-service/v1/organisation/{organisation_id}/projects?limit=10&amp;cursor=abc123\" \\\n  -H \"Authorization: Bearer YOUR_TOKEN\"\n</code></pre> <pre><code>func listProjects(client organisationv1.OrganisationServiceClient, orgId string) {\n    req := &amp;organisationv1.GetProjectsForOrganisationRequest{\n        OrganisationId: orgId,\n        Pagination: &amp;paginationv1.PaginationRequest{\n            Limit: proto.Int32(10),\n        },\n    }\n\n    resp, err := client.GetProjectsForOrganisation(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to list projects: %v\", err)\n    }\n\n    for _, project := range resp.Projects {\n        log.Printf(\"Project: %s\", project.Name)\n    }\n}\n</code></pre> <pre><code>use permio_proto::pagination::PaginationRequest;\n\nasync fn list_projects(client: &amp;mut OrganisationServiceClient&lt;Channel&gt;, org_id: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(GetProjectsForOrganisationRequest {\n        organisation_id: org_id.to_string(),\n        pagination: Some(PaginationRequest {\n            limit: Some(10),\n            cursor: None,\n        }),\n        search: None,\n    });\n\n    let response = client.get_projects_for_organisation(request).await?;\n\n    for project in response.get_ref().projects.iter() {\n        println!(\"Project: {}\", project.name);\n    }\n\n    Ok(())\n}\n</code></pre> <pre><code>def list_projects(org_id: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = organisation_service_pb2_grpc.OrganisationServiceStub(channel)\n\n    request = organisation_service_pb2.GetProjectsForOrganisationRequest(\n        organisation_id=org_id,\n        pagination=pagination_pb2.PaginationRequest(limit=10)\n    )\n\n    response = client.GetProjectsForOrganisation(request)\n\n    for project in response.projects:\n        print(f\"Project: {project.name}\")\n</code></pre> <pre><code>public void listProjects(String orgId) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    OrganisationServiceGrpc.OrganisationServiceBlockingStub client = \n            OrganisationServiceGrpc.newBlockingStub(channel);\n\n    GetProjectsForOrganisationRequest request = GetProjectsForOrganisationRequest.newBuilder()\n            .setOrganisationId(orgId)\n            .setPagination(PaginationRequest.newBuilder().setLimit(10).build())\n            .build();\n\n    GetProjectsForOrganisationResponse response = client.getProjectsForOrganisation(request);\n\n    for (Project project : response.getProjectsList()) {\n        System.out.println(\"Project: \" + project.getName());\n    }\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface GetProjectsForOrganisationRequest {\n    organisation_id: string;\n    pagination?: {\n        limit?: number;\n        cursor?: string;\n    };\n    search?: string;\n}\n\nfunction listProjects(orgId: string): void {\n    const request: GetProjectsForOrganisationRequest = {\n        organisation_id: orgId,\n        pagination: {\n            limit: 10\n        }\n    };\n\n    client.GetProjectsForOrganisation(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n\n        response.projects.forEach((project: any) =&gt; {\n            console.log(`Project: ${project.name}`);\n        });\n    });\n}\n</code></pre>"},{"location":"api-reference/organizations/#api-key-management","title":"API Key Management","text":"<p>API keys are created and managed through the dashboard. Use the API to list your existing keys.</p>"},{"location":"api-reference/organizations/#list-api-keys","title":"List API Keys","text":"<p>Lists all API keys for a project. Requires <code>apiKeys.list</code> permission.</p> cURL <pre><code>curl -X GET \"https://api.perms.io/organisation-service/v1/organisation/{organisation_id}/api-key?project_name={project_name}\" \\\n  -H \"Authorization: Bearer YOUR_TOKEN\"\n</code></pre>"},{"location":"api-reference/organizations/#user-management","title":"User Management","text":""},{"location":"api-reference/organizations/#invite-user-to-organisation","title":"Invite User to Organisation","text":"<p>Invites a user to join an organisation via email.</p> cURLGoRustPythonJavaTypeScript <pre><code>curl -X POST \"https://api.perms.io/organisation-service/v1/organisation/{organisation_id}/invite\" \\\n  -H \"Authorization: Bearer YOUR_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"email\": \"user@example.com\"\n  }'\n</code></pre> <pre><code>func inviteUser(client organisationv1.OrganisationServiceClient, orgId, email string) {\n    req := &amp;organisationv1.InviteUserToOrganisationRequest{\n        OrganisationId: orgId,\n        Email:         email,\n    }\n\n    _, err := client.InviteUserToOrganisation(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to invite user: %v\", err)\n    }\n\n    log.Printf(\"Invited user: %s\", email)\n}\n</code></pre> <pre><code>async fn invite_user(client: &amp;mut OrganisationServiceClient&lt;Channel&gt;, org_id: &amp;str, email: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(InviteUserToOrganisationRequest {\n        organisation_id: org_id.to_string(),\n        email: email.to_string(),\n    });\n\n    client.invite_user_to_organisation(request).await?;\n    println!(\"Invited user: {}\", email);\n\n    Ok(())\n}\n</code></pre> <pre><code>def invite_user(org_id: str, email: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = organisation_service_pb2_grpc.OrganisationServiceStub(channel)\n\n    request = organisation_service_pb2.InviteUserToOrganisationRequest(\n        organisation_id=org_id,\n        email=email\n    )\n\n    client.InviteUserToOrganisation(request)\n    print(f\"Invited user: {email}\")\n</code></pre> <pre><code>public void inviteUser(String orgId, String email) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    OrganisationServiceGrpc.OrganisationServiceBlockingStub client = \n            OrganisationServiceGrpc.newBlockingStub(channel);\n\n    InviteUserToOrganisationRequest request = InviteUserToOrganisationRequest.newBuilder()\n            .setOrganisationId(orgId)\n            .setEmail(email)\n            .build();\n\n    client.inviteUserToOrganisation(request);\n    System.out.println(\"Invited user: \" + email);\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface InviteUserToOrganisationRequest {\n    organisation_id: string;\n    email: string;\n}\n\nfunction inviteUser(orgId: string, email: string): void {\n    const request: InviteUserToOrganisationRequest = {\n        organisation_id: orgId,\n        email: email\n    };\n\n    client.InviteUserToOrganisation(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Invited user: ${email}`);\n    });\n}\n</code></pre>"},{"location":"api-reference/organizations/#remove-user-from-organisation","title":"Remove User from Organisation","text":"<p>Removes a user from an organisation. Requires <code>organisation.user.remove</code> permission.</p> cURL <pre><code>curl -X POST \"https://api.perms.io/organisation-service/v1/organisation/{organisation_id}/user/{user_id}\" \\\n  -H \"Authorization: Bearer YOUR_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{}'\n</code></pre>"},{"location":"api-reference/organizations/#get-users-organisation","title":"Get User's Organisation","text":"<p>Retrieves the organisation associated with a user. Requires <code>user.organisation.get</code> permission.</p> cURL <pre><code>curl -X GET \"https://api.perms.io/organisation-service/v1/organisation/user\" \\\n  -H \"Authorization: Bearer YOUR_TOKEN\"\n</code></pre>"},{"location":"api-reference/organizations/#dashboard-analytics","title":"Dashboard &amp; Analytics","text":""},{"location":"api-reference/organizations/#get-dashboard","title":"Get Dashboard","text":"<p>Retrieves dashboard statistics for an organisation. Requires <code>organisation.dashboard.view</code> permission.</p> cURLGoRustPythonJavaTypeScript <pre><code>curl -X GET \"https://api.perms.io/organisation-service/v1/organisation/{organisation_id}/dashboard\" \\\n  -H \"Authorization: Bearer YOUR_TOKEN\"\n</code></pre> <pre><code>func getDashboard(client organisationv1.OrganisationServiceClient, orgId string) {\n    req := &amp;organisationv1.GetOrganisationDashboardRequest{\n        OrganisationId: orgId,\n    }\n\n    resp, err := client.GetOrganisationDashboard(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to get dashboard: %v\", err)\n    }\n\n    log.Printf(\"Dashboard stats - Roles: %d, Permissions: %d, Principals: %d, Users: %d\",\n        resp.TotalRoles, resp.TotalPermissions, resp.TotalPrincipals, resp.TotalUsers)\n}\n</code></pre> <pre><code>async fn get_dashboard(client: &amp;mut OrganisationServiceClient&lt;Channel&gt;, org_id: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(GetOrganisationDashboardRequest {\n        organisation_id: org_id.to_string(),\n    });\n\n    let response = client.get_organisation_dashboard(request).await?;\n    let dashboard = response.get_ref();\n\n    println!(\"Dashboard stats - Roles: {}, Permissions: {}, Principals: {}, Users: {}\",\n        dashboard.total_roles, dashboard.total_permissions, dashboard.total_principals, dashboard.total_users);\n\n    Ok(())\n}\n</code></pre> <pre><code>def get_dashboard(org_id: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = organisation_service_pb2_grpc.OrganisationServiceStub(channel)\n\n    request = organisation_service_pb2.GetOrganisationDashboardRequest(\n        organisation_id=org_id\n    )\n\n    response = client.GetOrganisationDashboard(request)\n    print(f\"Dashboard stats - Roles: {response.total_roles}, Permissions: {response.total_permissions}, \"\n          f\"Principals: {response.total_principals}, Users: {response.total_users}\")\n</code></pre> <pre><code>public void getDashboard(String orgId) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    OrganisationServiceGrpc.OrganisationServiceBlockingStub client = \n            OrganisationServiceGrpc.newBlockingStub(channel);\n\n    GetOrganisationDashboardRequest request = GetOrganisationDashboardRequest.newBuilder()\n            .setOrganisationId(orgId)\n            .build();\n\n    GetOrganisationDashboardResponse response = client.getOrganisationDashboard(request);\n    System.out.println(String.format(\"Dashboard stats - Roles: %d, Permissions: %d, Principals: %d, Users: %d\",\n            response.getTotalRoles(), response.getTotalPermissions(), \n            response.getTotalPrincipals(), response.getTotalUsers()));\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface GetOrganisationDashboardRequest {\n    organisation_id: string;\n}\n\nfunction getDashboard(orgId: string): void {\n    const request: GetOrganisationDashboardRequest = {\n        organisation_id: orgId\n    };\n\n    client.GetOrganisationDashboard(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Dashboard stats - Roles: ${response.total_roles}, Permissions: ${response.total_permissions}, ` +\n                   `Principals: ${response.total_principals}, Users: ${response.total_users}`);\n    });\n}\n</code></pre>"},{"location":"api-reference/organizations/#get-principal-usage-stats","title":"Get Principal Usage Stats","text":"<p>Retrieves usage statistics for billing purposes. Requires <code>billing.view</code> permission.</p> cURL <pre><code>curl -X GET \"https://api.perms.io/organisation-service/v1/organisation/{organisation_id}/principal-usage\" \\\n  -H \"Authorization: Bearer YOUR_TOKEN\"\n</code></pre>"},{"location":"api-reference/organizations/#get-usage-history","title":"Get Usage History","text":"<p>Retrieves historical usage data for charting. Requires <code>billing.view</code> permission.</p> cURL <pre><code>curl -X GET \"https://api.perms.io/organisation-service/v1/organisation/{organisation_id}/usage-history?days=30\" \\\n  -H \"Authorization: Bearer YOUR_TOKEN\"\n</code></pre>"},{"location":"api-reference/organizations/#error-handling","title":"Error Handling","text":"<p>The service returns standard gRPC status codes:</p> <ul> <li><code>OK</code> (0): Success</li> <li><code>INVALID_ARGUMENT</code> (3): Invalid request parameters</li> <li><code>NOT_FOUND</code> (5): Resource not found</li> <li><code>PERMISSION_DENIED</code> (7): Insufficient permissions</li> <li><code>ALREADY_EXISTS</code> (6): Resource already exists</li> <li><code>RESOURCE_EXHAUSTED</code> (8): Rate limit exceeded</li> </ul>"},{"location":"api-reference/organizations/#example-error-response","title":"Example Error Response","text":"<pre><code>{\n  \"error\": {\n    \"code\": 7,\n    \"message\": \"Permission denied: missing required permission 'project.create' on resource '/organisation/org_123'\"\n  }\n}\n</code></pre>"},{"location":"api-reference/organizations/#rate-limits","title":"Rate Limits","text":"<p>API requests are subject to rate limiting: - Authenticated users: 1000 requests per hour - API keys: 10000 requests per hour - Burst limit: 100 requests per minute</p>"},{"location":"api-reference/organizations/#setup-instructions","title":"Setup Instructions","text":"<p>To set up your organization structure:</p> <ol> <li>Create Organization: Use the dashboard to create your organization</li> <li>Add Projects: Create projects for different environments or applications</li> <li>Generate API Keys: Create API keys for programmatic access to specific projects</li> <li>Invite Users: Add team members to your organization</li> <li>Configure Permissions: Use the permissions API to set up your access control</li> </ol> <p>For detailed setup instructions, see the Quick Start Guide.</p>"},{"location":"api-reference/pagination/","title":"Pagination","text":"<p>The perms.io API uses cursor-based pagination for efficient traversal of large result sets. This approach provides consistent performance regardless of the dataset size and handles real-time data changes gracefully.</p>"},{"location":"api-reference/pagination/#overview","title":"Overview","text":"<p>Cursor-based pagination uses opaque tokens to mark positions in result sets, making it ideal for: - Large datasets with frequent updates - Real-time applications requiring consistent performance - APIs that need to handle concurrent modifications</p>"},{"location":"api-reference/pagination/#pagination-request","title":"Pagination Request","text":"<p>All list endpoints support optional pagination parameters:</p> <pre><code>message PaginationRequest {\n  // The number of items to return. Must be between 1 and 100. Default is 10.\n  optional int32 limit = 1;\n  // The cursor to start from. If not provided, starts from the beginning.\n  optional string cursor = 2;\n}\n</code></pre>"},{"location":"api-reference/pagination/#parameters","title":"Parameters","text":"<ul> <li>limit: Number of items per page (1-100, default: 10)</li> <li>cursor: Token indicating where to start the next page</li> </ul>"},{"location":"api-reference/pagination/#pagination-response","title":"Pagination Response","text":"<p>List endpoints return pagination metadata in their responses:</p> <pre><code>message PaginationResponse {\n  // The next cursor to use for the next page of results. If there are no more pages, this will be empty.\n  string next_cursor = 1;\n}\n</code></pre>"},{"location":"api-reference/pagination/#response-fields","title":"Response Fields","text":"<ul> <li>next_cursor: Token for the next page (empty if no more pages)</li> </ul>"},{"location":"api-reference/pagination/#usage-examples","title":"Usage Examples","text":""},{"location":"api-reference/pagination/#basic-pagination","title":"Basic Pagination","text":"cURLGoRustPythonJavaTypeScript <pre><code>curl -X GET \"https://api.perms.io/permissions-service/v1/permissions?project_name=production&amp;limit=10\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre> <pre><code>{\n  \"permissions\": [...],\n  \"pagination\": {\n    \"next_cursor\": \"eyJpZCI6IjEyMyIsInRzIjoiMjAyNC0wMS0xNVQxMDowMDowMFoifQ==\"\n  }\n}\n</code></pre> <pre><code>func listAllPermissions(client permissionsv1.PermissionsServiceClient, projectName string) {\n    var allPermissions []*permissionsv1.Permission\n    var cursor *string\n\n    for {\n        req := &amp;permissionsv1.ListPermissionsRequest{\n            ProjectName: projectName,\n            Pagination: &amp;paginationv1.PaginationRequest{\n                Limit: proto.Int32(50),\n            },\n        }\n\n        if cursor != nil {\n            req.Pagination.Cursor = cursor\n        }\n\n        resp, err := client.ListPermissions(context.Background(), req)\n        if err != nil {\n            log.Fatalf(\"Failed to list permissions: %v\", err)\n        }\n\n        allPermissions = append(allPermissions, resp.Permissions...)\n\n        // Check if there are more pages\n        if resp.Pagination.NextCursor == \"\" {\n            break\n        }\n        cursor = &amp;resp.Pagination.NextCursor\n    }\n\n    log.Printf(\"Retrieved %d total permissions\", len(allPermissions))\n}\n</code></pre> <pre><code>use permio_proto::permissions::v1::{\n    permissions_service_client::PermissionsServiceClient,\n    ListPermissionsRequest,\n};\nuse permio_proto::pagination::PaginationRequest;\nuse tonic::transport::Channel;\n\nasync fn list_all_permissions(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, project_name: &amp;str) -&gt; Result&lt;Vec&lt;Permission&gt;, Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut all_permissions = Vec::new();\n    let mut cursor: Option&lt;String&gt; = None;\n\n    loop {\n        let mut pagination = PaginationRequest {\n            limit: Some(50),\n            cursor: cursor.clone(),\n        };\n\n        let request = tonic::Request::new(ListPermissionsRequest {\n            project_name: project_name.to_string(),\n            pagination: Some(pagination),\n            search: None,\n        });\n\n        let response = client.list_permissions(request).await?;\n        let list_response = response.get_ref();\n\n        all_permissions.extend(list_response.permissions.clone());\n\n        // Check if there are more pages\n        if let Some(pagination_response) = &amp;list_response.pagination {\n            if pagination_response.next_cursor.is_empty() {\n                break;\n            }\n            cursor = Some(pagination_response.next_cursor.clone());\n        } else {\n            break;\n        }\n    }\n\n    println!(\"Retrieved {} total permissions\", all_permissions.len());\n    Ok(all_permissions)\n}\n</code></pre> <pre><code>def list_all_permissions(client, project_name: str):\n    all_permissions = []\n    cursor = None\n\n    while True:\n        request = permissions_service_pb2.ListPermissionsRequest(\n            project_name=project_name,\n            pagination=pagination_pb2.PaginationRequest(limit=50)\n        )\n\n        if cursor:\n            request.pagination.cursor = cursor\n\n        response = client.ListPermissions(request)\n        all_permissions.extend(response.permissions)\n\n        # Check if there are more pages\n        if not response.pagination.next_cursor:\n            break\n        cursor = response.pagination.next_cursor\n\n    print(f\"Retrieved {len(all_permissions)} total permissions\")\n    return all_permissions\n</code></pre> <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport permio.permissions.v1.PermissionsServiceGrpc;\nimport permio.permissions.v1.Permissions.ListPermissionsRequest;\nimport permio.permissions.v1.Permissions.ListPermissionsResponse;\nimport permio.permissions.v1.Permissions.Permission;\nimport permio.pagination.PaginationOuterClass.PaginationRequest;\n\npublic List&lt;Permission&gt; listAllPermissions(PermissionsServiceGrpc.PermissionsServiceBlockingStub client, String projectName) {\n    List&lt;Permission&gt; allPermissions = new ArrayList&lt;&gt;();\n    String cursor = null;\n\n    while (true) {\n        PaginationRequest.Builder paginationBuilder = PaginationRequest.newBuilder()\n                .setLimit(50);\n\n        if (cursor != null) {\n            paginationBuilder.setCursor(cursor);\n        }\n\n        ListPermissionsRequest request = ListPermissionsRequest.newBuilder()\n                .setProjectName(projectName)\n                .setPagination(paginationBuilder.build())\n                .build();\n\n        ListPermissionsResponse response = client.listPermissions(request);\n        allPermissions.addAll(response.getPermissionsList());\n\n        // Check if there are more pages\n        if (response.getPagination().getNextCursor().isEmpty()) {\n            break;\n        }\n        cursor = response.getPagination().getNextCursor();\n    }\n\n    System.out.println(\"Retrieved \" + allPermissions.size() + \" total permissions\");\n    return allPermissions;\n}\n</code></pre> <pre><code>interface ListPermissionsRequest {\n    project_name: string;\n    pagination?: {\n        limit?: number;\n        cursor?: string;\n    };\n    search?: string;\n}\n\ninterface Permission {\n    id: string;\n    name: string;\n    description: string;\n}\n\nasync function listAllPermissions(client: any, projectName: string): Promise&lt;Permission[]&gt; {\n    const allPermissions: Permission[] = [];\n    let cursor: string | null = null;\n\n    while (true) {\n        const request: ListPermissionsRequest = {\n            project_name: projectName,\n            pagination: { limit: 50 }\n        };\n\n        if (cursor) {\n            request.pagination!.cursor = cursor;\n        }\n\n        const response = await new Promise&lt;any&gt;((resolve, reject) =&gt; {\n            client.ListPermissions(request, (error: Error | null, response: any) =&gt; {\n                if (error) reject(error);\n                else resolve(response);\n            });\n        });\n\n        allPermissions.push(...response.permissions);\n\n        // Check if there are more pages\n        if (!response.pagination.next_cursor) {\n            break;\n        }\n        cursor = response.pagination.next_cursor;\n    }\n\n    console.log(`Retrieved ${allPermissions.length} total permissions`);\n    return allPermissions;\n}\n</code></pre>"},{"location":"api-reference/pagination/#next-page-request","title":"Next Page Request","text":"cURL <pre><code>curl -X GET \"https://api.perms.io/permissions-service/v1/permissions?project_name=production&amp;limit=10&amp;cursor=eyJpZCI6IjEyMyIsInRzIjoiMjAyNC0wMS0xNVQxMDowMDowMFoifQ==\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre>"},{"location":"api-reference/pagination/#handling-search-with-pagination","title":"Handling Search with Pagination","text":"<p>When using search parameters, pagination works the same way:</p> cURLGoRustPythonJavaTypeScript <pre><code>curl -X GET \"https://api.perms.io/permissions-service/v1/permissions?project_name=production&amp;search=document&amp;limit=10\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre> <pre><code>func searchPermissions(client permissionsv1.PermissionsServiceClient, projectName, searchTerm string) {\n    req := &amp;permissionsv1.ListPermissionsRequest{\n        ProjectName: projectName,\n        Search:      proto.String(searchTerm),\n        Pagination: &amp;paginationv1.PaginationRequest{\n            Limit: proto.Int32(20),\n        },\n    }\n\n    resp, err := client.ListPermissions(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to search permissions: %v\", err)\n    }\n\n    log.Printf(\"Found %d permissions matching '%s'\", len(resp.Permissions), searchTerm)\n\n    // Process next page if available\n    if resp.Pagination.NextCursor != \"\" {\n        log.Printf(\"Next page available with cursor: %s\", resp.Pagination.NextCursor)\n    }\n}\n</code></pre> <pre><code>async fn search_permissions(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, project_name: &amp;str, search_term: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(ListPermissionsRequest {\n        project_name: project_name.to_string(),\n        search: Some(search_term.to_string()),\n        pagination: Some(PaginationRequest {\n            limit: Some(20),\n            cursor: None,\n        }),\n    });\n\n    let response = client.list_permissions(request).await?;\n    let list_response = response.get_ref();\n\n    println!(\"Found {} permissions matching '{}'\", list_response.permissions.len(), search_term);\n\n    // Process next page if available\n    if let Some(pagination) = &amp;list_response.pagination {\n        if !pagination.next_cursor.is_empty() {\n            println!(\"Next page available with cursor: {}\", pagination.next_cursor);\n        }\n    }\n\n    Ok(())\n}\n</code></pre> <pre><code>def search_permissions(client, project_name: str, search_term: str):\n    request = permissions_service_pb2.ListPermissionsRequest(\n        project_name=project_name,\n        search=search_term,\n        pagination=pagination_pb2.PaginationRequest(limit=20)\n    )\n\n    response = client.ListPermissions(request)\n\n    print(f\"Found {len(response.permissions)} permissions matching '{search_term}'\")\n\n    # Process next page if available\n    if response.pagination.next_cursor:\n        print(f\"Next page available with cursor: {response.pagination.next_cursor}\")\n</code></pre> <pre><code>public void searchPermissions(PermissionsServiceGrpc.PermissionsServiceBlockingStub client, String projectName, String searchTerm) {\n    ListPermissionsRequest request = ListPermissionsRequest.newBuilder()\n            .setProjectName(projectName)\n            .setSearch(searchTerm)\n            .setPagination(PaginationRequest.newBuilder().setLimit(20).build())\n            .build();\n\n    ListPermissionsResponse response = client.listPermissions(request);\n\n    System.out.println(\"Found \" + response.getPermissionsCount() + \" permissions matching '\" + searchTerm + \"'\");\n\n    // Process next page if available\n    if (!response.getPagination().getNextCursor().isEmpty()) {\n        System.out.println(\"Next page available with cursor: \" + response.getPagination().getNextCursor());\n    }\n}\n</code></pre> <pre><code>function searchPermissions(client: any, projectName: string, searchTerm: string): void {\n    const request: ListPermissionsRequest = {\n        project_name: projectName,\n        search: searchTerm,\n        pagination: {\n            limit: 20\n        }\n    };\n\n    client.ListPermissions(request, (error: Error | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n\n        console.log(`Found ${response.permissions.length} permissions matching '${searchTerm}'`);\n\n        // Process next page if available\n        if (response.pagination.next_cursor) {\n            console.log(`Next page available with cursor: ${response.pagination.next_cursor}`);\n        }\n    });\n}\n</code></pre>"},{"location":"api-reference/pagination/#best-practices","title":"Best Practices","text":""},{"location":"api-reference/pagination/#1-choose-appropriate-page-sizes","title":"1. Choose Appropriate Page Sizes","text":"<ul> <li>Small pages (10-25): Better for user interfaces, real-time updates</li> <li>Medium pages (50-100): Good balance for most use cases</li> <li>Large pages (100): Better for bulk operations, data processing</li> </ul>"},{"location":"api-reference/pagination/#2-handle-empty-results","title":"2. Handle Empty Results","text":"<p>Always check for empty result sets:</p> <pre><code>if len(resp.Permissions) == 0 {\n    log.Printf(\"No permissions found\")\n    return\n}\n</code></pre>"},{"location":"api-reference/pagination/#3-store-cursors-appropriately","title":"3. Store Cursors Appropriately","text":"<ul> <li>Short-term: Store in memory or session storage</li> <li>Long-term: Store in database for resumable operations</li> <li>Never: Attempt to decode or manipulate cursor values</li> </ul>"},{"location":"api-reference/pagination/#4-implement-retry-logic","title":"4. Implement Retry Logic","text":"<pre><code>func listPermissionsWithRetry(client permissionsv1.PermissionsServiceClient, req *permissionsv1.ListPermissionsRequest) (*permissionsv1.ListPermissionsResponse, error) {\n    maxRetries := 3\n    for i := 0; i &lt; maxRetries; i++ {\n        resp, err := client.ListPermissions(context.Background(), req)\n        if err == nil {\n            return resp, nil\n        }\n\n        if i == maxRetries-1 {\n            return nil, err\n        }\n\n        // Exponential backoff\n        time.Sleep(time.Duration(1&lt;&lt;i) * time.Second)\n    }\n    return nil, nil\n}\n</code></pre>"},{"location":"api-reference/pagination/#5-monitor-performance","title":"5. Monitor Performance","text":"<p>Track pagination performance metrics: - Average response times by page size - Memory usage for large result sets - Error rates for different cursor ages</p>"},{"location":"api-reference/pagination/#pagination-patterns","title":"Pagination Patterns","text":""},{"location":"api-reference/pagination/#simple-iteration","title":"Simple Iteration","text":"<p>For processing all items in a collection:</p> <pre><code>func processAllRoles(client permissionsv1.PermissionsServiceClient, projectName string) {\n    var cursor *string\n\n    for {\n        roles, nextCursor, err := getRolesPage(client, projectName, cursor, 50)\n        if err != nil {\n            log.Printf(\"Error fetching roles: %v\", err)\n            break\n        }\n\n        // Process each role\n        for _, role := range roles {\n            processRole(role)\n        }\n\n        if nextCursor == \"\" {\n            break\n        }\n        cursor = &amp;nextCursor\n    }\n}\n</code></pre>"},{"location":"api-reference/pagination/#concurrent-processing","title":"Concurrent Processing","text":"<p>For parallel processing of paginated results:</p> <pre><code>func processPrincipalsAsync(client permissionsv1.PermissionsServiceClient, projectName string) {\n    type pageResult struct {\n        principals []*string\n        cursor     string\n        err        error\n    }\n\n    resultChan := make(chan pageResult, 10)\n    var wg sync.WaitGroup\n\n    // Start first page\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        principals, cursor, err := getPrincipalsPage(client, projectName, nil, 100)\n        resultChan &lt;- pageResult{principals, cursor, err}\n    }()\n\n    // Process results and spawn next page requests\n    go func() {\n        for result := range resultChan {\n            if result.err != nil {\n                log.Printf(\"Error: %v\", result.err)\n                continue\n            }\n\n            // Process principals\n            for _, principal := range result.principals {\n                log.Printf(\"Processing principal: %s\", *principal)\n            }\n\n            // Spawn next page if available\n            if result.cursor != \"\" {\n                wg.Add(1)\n                go func(cursor string) {\n                    defer wg.Done()\n                    principals, nextCursor, err := getPrincipalsPage(client, projectName, &amp;cursor, 100)\n                    resultChan &lt;- pageResult{principals, nextCursor, err}\n                }(result.cursor)\n            }\n        }\n    }()\n\n    wg.Wait()\n    close(resultChan)\n}\n</code></pre>"},{"location":"api-reference/pagination/#error-handling","title":"Error Handling","text":""},{"location":"api-reference/pagination/#cursor-expiration","title":"Cursor Expiration","text":"<p>Cursors may expire after a certain period. Handle this gracefully:</p> <pre><code>func handleCursorExpiration(client permissionsv1.PermissionsServiceClient, req *permissionsv1.ListPermissionsRequest) {\n    resp, err := client.ListPermissions(context.Background(), req)\n    if err != nil {\n        if isCursorExpiredError(err) {\n            log.Printf(\"Cursor expired, restarting from beginning\")\n            req.Pagination.Cursor = nil\n            resp, err = client.ListPermissions(context.Background(), req)\n        }\n\n        if err != nil {\n            log.Fatalf(\"Failed to list permissions: %v\", err)\n        }\n    }\n\n    // Process response...\n}\n</code></pre>"},{"location":"api-reference/pagination/#rate-limiting","title":"Rate Limiting","text":"<p>Implement rate limiting between requests:</p> <pre><code>func listWithRateLimit(client permissionsv1.PermissionsServiceClient, projectName string) {\n    rateLimiter := time.NewTicker(100 * time.Millisecond)\n    defer rateLimiter.Stop()\n\n    var cursor *string\n\n    for {\n        &lt;-rateLimiter.C // Wait for rate limit\n\n        roles, nextCursor, err := getRolesPage(client, projectName, cursor, 50)\n        if err != nil {\n            log.Printf(\"Error: %v\", err)\n            break\n        }\n\n        processRoles(roles)\n\n        if nextCursor == \"\" {\n            break\n        }\n        cursor = &amp;nextCursor\n    }\n}\n</code></pre>"},{"location":"api-reference/pagination/#limitations","title":"Limitations","text":"<ul> <li>Maximum limit: 100 items per page</li> <li>Cursor lifetime: Cursors expire after 24 hours</li> <li>Sort stability: Results are sorted by creation time and ID</li> <li>Concurrent modifications: Results may include items created during iteration</li> </ul>"},{"location":"api-reference/pagination/#endpoints-supporting-pagination","title":"Endpoints Supporting Pagination","text":"<p>All list endpoints support pagination:</p> <ul> <li><code>ListPermissions</code></li> <li><code>ListRoles</code> </li> <li><code>ListPrincipals</code></li> <li><code>GetAllAssignmentsForPrincipal</code></li> <li><code>ListAPIKeys</code></li> <li><code>GetProjectsForOrganisation</code></li> </ul>"},{"location":"api-reference/pagination/#migration-from-offset-based-pagination","title":"Migration from Offset-Based Pagination","text":"<p>If migrating from offset-based pagination:</p> <pre><code>// Old offset-based approach\nfunc listPermissionsOffset(offset, limit int) {\n    // This approach doesn't work with cursor-based pagination\n}\n\n// New cursor-based approach\nfunc listPermissionsCursor(cursor *string, limit int) {\n    req := &amp;permissionsv1.ListPermissionsRequest{\n        ProjectName: \"production\",\n        Pagination: &amp;paginationv1.PaginationRequest{\n            Limit: proto.Int32(int32(limit)),\n        },\n    }\n\n    if cursor != nil {\n        req.Pagination.Cursor = cursor\n    }\n\n    // Make request...\n}\n</code></pre>"},{"location":"api-reference/pagination/#testing-pagination","title":"Testing Pagination","text":""},{"location":"api-reference/pagination/#unit-tests","title":"Unit Tests","text":"<pre><code>func TestPaginationFlow(t *testing.T) {\n    // Mock client setup\n    client := &amp;mockPermissionsClient{}\n\n    // Test first page\n    resp1, err := client.ListPermissions(context.Background(), &amp;permissionsv1.ListPermissionsRequest{\n        ProjectName: \"test\",\n        Pagination: &amp;paginationv1.PaginationRequest{\n            Limit: proto.Int32(2),\n        },\n    })\n    assert.NoError(t, err)\n    assert.Len(t, resp1.Permissions, 2)\n    assert.NotEmpty(t, resp1.Pagination.NextCursor)\n\n    // Test second page\n    resp2, err := client.ListPermissions(context.Background(), &amp;permissionsv1.ListPermissionsRequest{\n        ProjectName: \"test\",\n        Pagination: &amp;paginationv1.PaginationRequest{\n            Limit:  proto.Int32(2),\n            Cursor: &amp;resp1.Pagination.NextCursor,\n        },\n    })\n    assert.NoError(t, err)\n    assert.Len(t, resp2.Permissions, 2)\n\n    // Verify different results\n    assert.NotEqual(t, resp1.Permissions[0].Id, resp2.Permissions[0].Id)\n}\n</code></pre>"},{"location":"api-reference/permissions/","title":"Permissions &amp; Roles","text":"<p>Manage permissions, roles, and access control through perms.io's Resource-Specific Role-Based Access Control (RBAC) system. Control who can access what resources in your application with fine-grained precision.</p>"},{"location":"api-reference/permissions/#overview","title":"Overview","text":"<p>The permissions system implements a hierarchical RBAC model with the following key components:</p> <ul> <li>Permissions: Individual actions that can be performed (e.g., <code>read</code>, <code>write</code>, <code>delete</code>)</li> <li>Roles: Collections of permissions that can be assigned as a group</li> <li>Principals: Users or entities that can be granted permissions</li> <li>Resources: Specific objects or paths that permissions apply to (e.g., <code>/project/123</code>, <code>/user/456/documents</code>)</li> </ul>"},{"location":"api-reference/permissions/#key-features","title":"Key Features","text":"<ul> <li>Resource-Specific Access: Permissions apply to specific resource URIs</li> <li>Hierarchical Inheritance: Permissions on parent resources cascade to child resources</li> <li>Flexible Principal Model: Support for users, service accounts, and other principal types</li> <li>High-Performance Checks: Optimized permission checking for real-time applications</li> </ul>"},{"location":"api-reference/permissions/#base-url","title":"Base URL","text":"<pre><code>https://api.perms.io/permissions-service/v1\n</code></pre>"},{"location":"api-reference/permissions/#permission-management","title":"Permission Management","text":""},{"location":"api-reference/permissions/#create-permission","title":"Create Permission","text":"<p>Creates a new permission within a project. Permissions are idempotent - creating an existing permission will update it.</p> <p>Required Permission: <code>permission.create</code> on <code>/organisation/{organisation_id}</code></p> cURLGoRustPythonJavaTypeScript <pre><code>curl -X POST \"https://api.perms.io/permissions-service/v1/permissions\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"name\": \"document.read\",\n    \"description\": \"Allows reading documents\"\n  }'\n</code></pre> <pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n\n    permissionsv1 \"github.com/PrivateJAR/permio-go/proto/permissions/v1\"\n)\n\nfunc createPermission(client permissionsv1.PermissionsServiceClient) {\n    req := &amp;permissionsv1.CreatePermissionRequest{\n        ProjectName: \"production\",\n        Name:        \"document.read\",\n        Description: \"Allows reading documents\",\n    }\n\n    resp, err := client.CreatePermission(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to create permission: %v\", err)\n    }\n\n    log.Printf(\"Created permission: %s (ID: %s)\", resp.Name, resp.Id)\n}\n</code></pre> <pre><code>use tonic::transport::Channel;\nuse permio_proto::permissions::v1::{\n    permissions_service_client::PermissionsServiceClient,\n    CreatePermissionRequest,\n};\n\nasync fn create_permission(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(CreatePermissionRequest {\n        project_name: \"production\".to_string(),\n        name: \"document.read\".to_string(),\n        description: \"Allows reading documents\".to_string(),\n    });\n\n    let response = client.create_permission(request).await?;\n    println!(\"Created permission: {} (ID: {})\", response.get_ref().name, response.get_ref().id);\n\n    Ok(())\n}\n</code></pre> <pre><code>import grpc\nfrom proto.permissions.v1 import permissions_service_pb2\nfrom proto.permissions.v1 import permissions_service_pb2_grpc\n\ndef create_permission():\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.CreatePermissionRequest(\n        project_name=\"production\",\n        name=\"document.read\",\n        description=\"Allows reading documents\"\n    )\n\n    response = client.CreatePermission(request)\n    print(f\"Created permission: {response.name} (ID: {response.id})\")\n</code></pre> <pre><code>import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport permio.permissions.v1.PermissionsServiceGrpc;\nimport permio.permissions.v1.Permissions.CreatePermissionRequest;\nimport permio.permissions.v1.Permissions.CreatePermissionResponse;\n\npublic void createPermission() {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    CreatePermissionRequest request = CreatePermissionRequest.newBuilder()\n            .setProjectName(\"production\")\n            .setName(\"document.read\")\n            .setDescription(\"Allows reading documents\")\n            .build();\n\n    CreatePermissionResponse response = client.createPermission(request);\n    System.out.println(\"Created permission: \" + response.getName() + \" (ID: \" + response.getId() + \")\");\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>import * as grpc from '@grpc/grpc-js';\nimport * as protoLoader from '@grpc/proto-loader';\n\nconst packageDefinition = protoLoader.loadSync('permissions_service.proto');\nconst permissionsService = grpc.loadPackageDefinition(packageDefinition).permissions.v1 as any;\n\nconst client = new permissionsService.PermissionsService('api.perms.io:443', \n    grpc.credentials.createSsl());\n\ninterface CreatePermissionRequest {\n    project_name: string;\n    name: string;\n    description: string;\n}\n\nfunction createPermission(): void {\n    const request: CreatePermissionRequest = {\n        project_name: 'production',\n        name: 'document.read',\n        description: 'Allows reading documents'\n    };\n\n    client.CreatePermission(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Created permission: ${response.name} (ID: ${response.id})`);\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#get-permission","title":"Get Permission","text":"<p>Retrieves details of a specific permission.</p> <p>Required Permission: <code>permission.get</code> on <code>/organisation/{organisation_id}/permission/{name}</code></p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X GET \"https://api.perms.io/permissions-service/v1/permissions/{name}?project_name=production\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre> <pre><code>func getPermission(client permissionsv1.PermissionsServiceClient, projectName, permissionName string) {\n    req := &amp;permissionsv1.GetPermissionRequest{\n        ProjectName: projectName,\n        Name:        permissionName,\n    }\n\n    resp, err := client.GetPermission(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to get permission: %v\", err)\n    }\n\n    log.Printf(\"Permission: %s - %s\", resp.Name, resp.Description)\n}\n</code></pre> <pre><code>async fn get_permission(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, project_name: &amp;str, permission_name: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(GetPermissionRequest {\n        project_name: project_name.to_string(),\n        name: permission_name.to_string(),\n    });\n\n    let response = client.get_permission(request).await?;\n    let permission = response.get_ref();\n    println!(\"Permission: {} - {}\", permission.name, permission.description);\n\n    Ok(())\n}\n</code></pre> <pre><code>def get_permission(project_name: str, permission_name: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.GetPermissionRequest(\n        project_name=project_name,\n        name=permission_name\n    )\n\n    response = client.GetPermission(request)\n    print(f\"Permission: {response.name} - {response.description}\")\n</code></pre> <pre><code>public void getPermission(String projectName, String permissionName) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    GetPermissionRequest request = GetPermissionRequest.newBuilder()\n            .setProjectName(projectName)\n            .setName(permissionName)\n            .build();\n\n    GetPermissionResponse response = client.getPermission(request);\n    System.out.println(\"Permission: \" + response.getName() + \" - \" + response.getDescription());\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface GetPermissionRequest {\n    project_name: string;\n    name: string;\n}\n\nfunction getPermission(projectName: string, permissionName: string): void {\n    const request: GetPermissionRequest = {\n        project_name: projectName,\n        name: permissionName\n    };\n\n    client.GetPermission(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Permission: ${response.name} - ${response.description}`);\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#update-permission","title":"Update Permission","text":"<p>Updates an existing permission.</p> <p>Required Permission: <code>permission.update</code> on <code>/organisation/{organisation_id}/permission/{name}</code></p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X PUT \"https://api.perms.io/permissions-service/v1/permissions/{name}\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"new_name\": \"document.read\",\n    \"description\": \"Updated description for reading documents\"\n  }'\n</code></pre> <pre><code>func updatePermission(client permissionsv1.PermissionsServiceClient, projectName, permissionName string) {\n    req := &amp;permissionsv1.UpdatePermissionRequest{\n        ProjectName: projectName,\n        Name:        permissionName,\n        NewName:     \"document.read\",\n        Description: \"Updated description for reading documents\",\n    }\n\n    resp, err := client.UpdatePermission(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to update permission: %v\", err)\n    }\n\n    log.Printf(\"Updated permission: %s\", resp.Name)\n}\n</code></pre> <pre><code>async fn update_permission(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, project_name: &amp;str, permission_name: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(UpdatePermissionRequest {\n        project_name: project_name.to_string(),\n        name: permission_name.to_string(),\n        new_name: Some(\"document.read\".to_string()),\n        description: \"Updated description for reading documents\".to_string(),\n    });\n\n    let response = client.update_permission(request).await?;\n    println!(\"Updated permission: {}\", response.get_ref().name);\n\n    Ok(())\n}\n</code></pre> <pre><code>def update_permission(project_name: str, permission_name: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.UpdatePermissionRequest(\n        project_name=project_name,\n        name=permission_name,\n        new_name=\"document.read\",\n        description=\"Updated description for reading documents\"\n    )\n\n    response = client.UpdatePermission(request)\n    print(f\"Updated permission: {response.name}\")\n</code></pre> <pre><code>public void updatePermission(String projectName, String permissionName) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    UpdatePermissionRequest request = UpdatePermissionRequest.newBuilder()\n            .setProjectName(projectName)\n            .setName(permissionName)\n            .setNewName(\"document.read\")\n            .setDescription(\"Updated description for reading documents\")\n            .build();\n\n    UpdatePermissionResponse response = client.updatePermission(request);\n    System.out.println(\"Updated permission: \" + response.getName());\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface UpdatePermissionRequest {\n    project_name: string;\n    name: string;\n    new_name?: string;\n    description: string;\n}\n\nfunction updatePermission(projectName: string, permissionName: string): void {\n    const request: UpdatePermissionRequest = {\n        project_name: projectName,\n        name: permissionName,\n        new_name: 'document.read',\n        description: 'Updated description for reading documents'\n    };\n\n    client.UpdatePermission(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Updated permission: ${response.name}`);\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#delete-permission","title":"Delete Permission","text":"<p>Deletes a permission. This operation is idempotent.</p> <p>Required Permission: <code>permission.delete</code> on <code>/organisation/{organisation_id}/permission/{name}</code></p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X DELETE \"https://api.perms.io/permissions-service/v1/permissions/{name}?project_name=production\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre> <pre><code>func deletePermission(client permissionsv1.PermissionsServiceClient, projectName, permissionName string) {\n    req := &amp;permissionsv1.DeletePermissionRequest{\n        ProjectName: projectName,\n        Name:        permissionName,\n    }\n\n    _, err := client.DeletePermission(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to delete permission: %v\", err)\n    }\n\n    log.Printf(\"Deleted permission: %s\", permissionName)\n}\n</code></pre> <pre><code>async fn delete_permission(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, project_name: &amp;str, permission_name: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(DeletePermissionRequest {\n        project_name: project_name.to_string(),\n        name: permission_name.to_string(),\n    });\n\n    client.delete_permission(request).await?;\n    println!(\"Deleted permission: {}\", permission_name);\n\n    Ok(())\n}\n</code></pre> <pre><code>def delete_permission(project_name: str, permission_name: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.DeletePermissionRequest(\n        project_name=project_name,\n        name=permission_name\n    )\n\n    client.DeletePermission(request)\n    print(f\"Deleted permission: {permission_name}\")\n</code></pre> <pre><code>public void deletePermission(String projectName, String permissionName) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    DeletePermissionRequest request = DeletePermissionRequest.newBuilder()\n            .setProjectName(projectName)\n            .setName(permissionName)\n            .build();\n\n    client.deletePermission(request);\n    System.out.println(\"Deleted permission: \" + permissionName);\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface DeletePermissionRequest {\n    project_name: string;\n    name: string;\n}\n\nfunction deletePermission(projectName: string, permissionName: string): void {\n    const request: DeletePermissionRequest = {\n        project_name: projectName,\n        name: permissionName\n    };\n\n    client.DeletePermission(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Deleted permission: ${permissionName}`);\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#list-permissions","title":"List Permissions","text":"<p>Lists all permissions within a project with optional search and pagination.</p> <p>Required Permission: <code>permission.list</code> on <code>/organisation/{organisation_id}</code></p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X GET \"https://api.perms.io/permissions-service/v1/permissions?project_name=production&amp;limit=10&amp;cursor=abc123&amp;search=document\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre> <pre><code>func listPermissions(client permissionsv1.PermissionsServiceClient, projectName string) {\n    req := &amp;permissionsv1.ListPermissionsRequest{\n        ProjectName: projectName,\n        Pagination: &amp;paginationv1.PaginationRequest{\n            Limit: proto.Int32(10),\n        },\n        Search: proto.String(\"document\"),\n    }\n\n    resp, err := client.ListPermissions(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to list permissions: %v\", err)\n    }\n\n    for _, permission := range resp.Permissions {\n        log.Printf(\"Permission: %s - %s\", permission.Name, permission.Description)\n    }\n}\n</code></pre> <pre><code>async fn list_permissions(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, project_name: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(ListPermissionsRequest {\n        project_name: project_name.to_string(),\n        pagination: Some(PaginationRequest {\n            limit: Some(10),\n            cursor: None,\n        }),\n        search: Some(\"document\".to_string()),\n    });\n\n    let response = client.list_permissions(request).await?;\n\n    for permission in response.get_ref().permissions.iter() {\n        println!(\"Permission: {} - {}\", permission.name, permission.description);\n    }\n\n    Ok(())\n}\n</code></pre> <pre><code>def list_permissions(project_name: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.ListPermissionsRequest(\n        project_name=project_name,\n        pagination=pagination_pb2.PaginationRequest(limit=10),\n        search=\"document\"\n    )\n\n    response = client.ListPermissions(request)\n\n    for permission in response.permissions:\n        print(f\"Permission: {permission.name} - {permission.description}\")\n</code></pre> <pre><code>public void listPermissions(String projectName) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    ListPermissionsRequest request = ListPermissionsRequest.newBuilder()\n            .setProjectName(projectName)\n            .setPagination(PaginationRequest.newBuilder().setLimit(10).build())\n            .setSearch(\"document\")\n            .build();\n\n    ListPermissionsResponse response = client.listPermissions(request);\n\n    for (Permission permission : response.getPermissionsList()) {\n        System.out.println(\"Permission: \" + permission.getName() + \" - \" + permission.getDescription());\n    }\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface ListPermissionsRequest {\n    project_name: string;\n    pagination?: {\n        limit?: number;\n        cursor?: string;\n    };\n    search?: string;\n}\n\nfunction listPermissions(projectName: string): void {\n    const request: ListPermissionsRequest = {\n        project_name: projectName,\n        pagination: {\n            limit: 10\n        },\n        search: \"document\"\n    };\n\n    client.ListPermissions(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n\n        response.permissions.forEach((permission: any) =&gt; {\n            console.log(`Permission: ${permission.name} - ${permission.description}`);\n        });\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#role-management","title":"Role Management","text":""},{"location":"api-reference/permissions/#create-role","title":"Create Role","text":"<p>Creates a new role with a collection of permissions.</p> <p>Required Permissions:  - <code>role.create</code> on <code>/organisation/{organisation_id}</code> - <code>permission.get</code> on <code>/organisation/{organisation_id}/permission/{permission_name}</code> for each permission</p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X POST \"https://api.perms.io/permissions-service/v1/roles\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"name\": \"document_editor\",\n    \"description\": \"Can read and write documents\",\n    \"permissions\": [\"document.read\", \"document.write\"]\n  }'\n</code></pre> <pre><code>func createRole(client permissionsv1.PermissionsServiceClient, projectName string, permissionNames []string) {\n    req := &amp;permissionsv1.CreateRoleRequest{\n        ProjectName: projectName,\n        Name:        \"document_editor\",\n        Description: \"Can read and write documents\",\n        Permissions: permissionNames,\n    }\n\n    resp, err := client.CreateRole(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to create role: %v\", err)\n    }\n\n    log.Printf(\"Created role: %s (ID: %s)\", resp.Name, resp.Id)\n}\n</code></pre> <pre><code>async fn create_role(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, permission_names: Vec&lt;String&gt;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(CreateRoleRequest {\n        project_name: \"production\".to_string(),\n        name: \"document_editor\".to_string(),\n        description: \"Can read and write documents\".to_string(),\n        permissions: permission_names,\n    });\n\n    let response = client.create_role(request).await?;\n    println!(\"Created role: {} (ID: {})\", response.get_ref().name, response.get_ref().id);\n\n    Ok(())\n}\n</code></pre> <pre><code>def create_role(permission_names: list[str]):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.CreateRoleRequest(\n        project_name=\"production\",\n        name=\"document_editor\",\n        description=\"Can read and write documents\",\n        permissions=permission_names\n    )\n\n    response = client.CreateRole(request)\n    print(f\"Created role: {response.name} (ID: {response.id})\")\n</code></pre> <pre><code>public void createRole(List&lt;String&gt; permissionNames) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    CreateRoleRequest request = CreateRoleRequest.newBuilder()\n            .setProjectName(\"production\")\n            .setName(\"document_editor\")\n            .setDescription(\"Can read and write documents\")\n            .addAllPermissions(permissionNames)\n            .build();\n\n    CreateRoleResponse response = client.createRole(request);\n    System.out.println(\"Created role: \" + response.getName() + \" (ID: \" + response.getId() + \")\");\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface CreateRoleRequest {\n    project_name: string;\n    name: string;\n    description: string;\n    permissions: string[];\n}\n\nfunction createRole(permissionNames: string[]): void {\n    const request: CreateRoleRequest = {\n        project_name: 'production',\n        name: 'document_editor',\n        description: 'Can read and write documents',\n        permissions: permissionNames\n    };\n\n    client.CreateRole(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Created role: ${response.name} (ID: ${response.id})`);\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#get-role","title":"Get Role","text":"<p>Retrieves details of a specific role, including all associated permissions.</p> <p>Required Permission: <code>role.get</code> on <code>/organisation/{organisation_id}/role/{id}</code></p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X GET \"https://api.perms.io/permissions-service/v1/roles/{id}?project_name=production\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre> <pre><code>func getRole(client permissionsv1.PermissionsServiceClient, projectName, roleId string) {\n    req := &amp;permissionsv1.GetRoleRequest{\n        ProjectName: projectName,\n        Id:          roleId,\n    }\n\n    resp, err := client.GetRole(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to get role: %v\", err)\n    }\n\n    log.Printf(\"Role: %s - %s (Permissions: %d)\", resp.Name, resp.Description, len(resp.Permissions))\n}\n</code></pre> <pre><code>async fn get_role(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, project_name: &amp;str, role_id: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(GetRoleRequest {\n        project_name: project_name.to_string(),\n        id: role_id.to_string(),\n    });\n\n    let response = client.get_role(request).await?;\n    let role = response.get_ref();\n    println!(\"Role: {} - {} (Permissions: {})\", role.name, role.description, role.permissions.len());\n\n    Ok(())\n}\n</code></pre> <pre><code>def get_role(project_name: str, role_id: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.GetRoleRequest(\n        project_name=project_name,\n        id=role_id\n    )\n\n    response = client.GetRole(request)\n    print(f\"Role: {response.name} - {response.description} (Permissions: {len(response.permissions)})\")\n</code></pre> <pre><code>public void getRole(String projectName, String roleId) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    GetRoleRequest request = GetRoleRequest.newBuilder()\n            .setProjectName(projectName)\n            .setId(roleId)\n            .build();\n\n    GetRoleResponse response = client.getRole(request);\n    System.out.println(\"Role: \" + response.getName() + \" - \" + response.getDescription() + \n            \" (Permissions: \" + response.getPermissionsList().size() + \")\");\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface GetRoleRequest {\n    project_name: string;\n    id: string;\n}\n\nfunction getRole(projectName: string, roleId: string): void {\n    const request: GetRoleRequest = {\n        project_name: projectName,\n        id: roleId\n    };\n\n    client.GetRole(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Role: ${response.name} - ${response.description} (Permissions: ${response.permissions.length})`);\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#update-role","title":"Update Role","text":"<p>Updates an existing role's permissions and metadata.</p> <p>Required Permission: <code>role.update</code> on <code>/organisation/{organisation_id}/role/{id}</code></p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X PUT \"https://api.perms.io/permissions-service/v1/roles/{id}\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"name\": \"document_editor\",\n    \"description\": \"Updated description\",\n    \"permissions\": [\"document.read\", \"document.write\", \"document.delete\"]\n  }'\n</code></pre> <pre><code>func updateRole(client permissionsv1.PermissionsServiceClient, projectName, roleId string, permissionNames []string) {\n    req := &amp;permissionsv1.UpdateRoleRequest{\n        ProjectName: projectName,\n        Id:          roleId,\n        Name:        \"document_editor\",\n        Description: \"Updated description\",\n        Permissions: permissionNames,\n    }\n\n    resp, err := client.UpdateRole(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to update role: %v\", err)\n    }\n\n    log.Printf(\"Updated role: %s\", resp.Name)\n}\n</code></pre> <pre><code>async fn update_role(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, project_name: &amp;str, role_id: &amp;str, permission_names: Vec&lt;String&gt;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(UpdateRoleRequest {\n        project_name: project_name.to_string(),\n        id: role_id.to_string(),\n        name: \"document_editor\".to_string(),\n        description: \"Updated description\".to_string(),\n        permissions: permission_names,\n    });\n\n    let response = client.update_role(request).await?;\n    println!(\"Updated role: {}\", response.get_ref().name);\n\n    Ok(())\n}\n</code></pre> <pre><code>def update_role(project_name: str, role_id: str, permission_names: list[str]):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.UpdateRoleRequest(\n        project_name=project_name,\n        id=role_id,\n        name=\"document_editor\",\n        description=\"Updated description\",\n        permissions=permission_names\n    )\n\n    response = client.UpdateRole(request)\n    print(f\"Updated role: {response.name}\")\n</code></pre> <pre><code>public void updateRole(String projectName, String roleId, List&lt;String&gt; permissionNames) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    UpdateRoleRequest request = UpdateRoleRequest.newBuilder()\n            .setProjectName(projectName)\n            .setId(roleId)\n            .setName(\"document_editor\")\n            .setDescription(\"Updated description\")\n            .addAllPermissions(permissionNames)\n            .build();\n\n    UpdateRoleResponse response = client.updateRole(request);\n    System.out.println(\"Updated role: \" + response.getName());\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface UpdateRoleRequest {\n    project_name: string;\n    id: string;\n    name: string;\n    description: string;\n    permissions: string[];\n}\n\nfunction updateRole(projectName: string, roleId: string, permissionNames: string[]): void {\n    const request: UpdateRoleRequest = {\n        project_name: projectName,\n        id: roleId,\n        name: 'document_editor',\n        description: 'Updated description',\n        permissions: permissionNames\n    };\n\n    client.UpdateRole(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Updated role: ${response.name}`);\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#delete-role","title":"Delete Role","text":"<p>Deletes a role. This operation is idempotent.</p> <p>Required Permission: <code>role.delete</code> on <code>/organisation/{organisation_id}/role/{id}</code></p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X DELETE \"https://api.perms.io/permissions-service/v1/roles/{id}?project_name=production\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre> <pre><code>func deleteRole(client permissionsv1.PermissionsServiceClient, projectName, roleId string) {\n    req := &amp;permissionsv1.DeleteRoleRequest{\n        ProjectName: projectName,\n        Id:          roleId,\n    }\n\n    _, err := client.DeleteRole(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to delete role: %v\", err)\n    }\n\n    log.Printf(\"Deleted role: %s\", roleId)\n}\n</code></pre> <pre><code>async fn delete_role(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, project_name: &amp;str, role_id: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(DeleteRoleRequest {\n        project_name: project_name.to_string(),\n        id: role_id.to_string(),\n    });\n\n    client.delete_role(request).await?;\n    println!(\"Deleted role: {}\", role_id);\n\n    Ok(())\n}\n</code></pre> <pre><code>def delete_role(project_name: str, role_id: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.DeleteRoleRequest(\n        project_name=project_name,\n        id=role_id\n    )\n\n    client.DeleteRole(request)\n    print(f\"Deleted role: {role_id}\")\n</code></pre> <pre><code>public void deleteRole(String projectName, String roleId) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    DeleteRoleRequest request = DeleteRoleRequest.newBuilder()\n            .setProjectName(projectName)\n            .setId(roleId)\n            .build();\n\n    client.deleteRole(request);\n    System.out.println(\"Deleted role: \" + roleId);\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface DeleteRoleRequest {\n    project_name: string;\n    id: string;\n}\n\nfunction deleteRole(projectName: string, roleId: string): void {\n    const request: DeleteRoleRequest = {\n        project_name: projectName,\n        id: roleId\n    };\n\n    client.DeleteRole(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Deleted role: ${roleId}`);\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#list-roles","title":"List Roles","text":"<p>Lists all roles within a project with optional search and pagination.</p> <p>Required Permission: <code>role.list</code> on <code>/organisation/{organisation_id}</code></p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X GET \"https://api.perms.io/permissions-service/v1/roles?project_name=production&amp;limit=10&amp;search=editor\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre> <pre><code>func listRoles(client permissionsv1.PermissionsServiceClient, projectName string) {\n    req := &amp;permissionsv1.ListRolesRequest{\n        ProjectName: projectName,\n        Pagination: &amp;paginationv1.PaginationRequest{\n            Limit: proto.Int32(10),\n        },\n        Search: proto.String(\"editor\"),\n    }\n\n    resp, err := client.ListRoles(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to list roles: %v\", err)\n    }\n\n    for _, role := range resp.Roles {\n        log.Printf(\"Role: %s - %s (Permissions: %d)\", role.Name, role.Description, len(role.Permissions))\n    }\n}\n</code></pre> <pre><code>async fn list_roles(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, project_name: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(ListRolesRequest {\n        project_name: project_name.to_string(),\n        pagination: Some(PaginationRequest {\n            limit: Some(10),\n            cursor: None,\n        }),\n        search: Some(\"editor\".to_string()),\n    });\n\n    let response = client.list_roles(request).await?;\n\n    for role in response.get_ref().roles.iter() {\n        println!(\"Role: {} - {} (Permissions: {})\", role.name, role.description, role.permissions.len());\n    }\n\n    Ok(())\n}\n</code></pre> <pre><code>def list_roles(project_name: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.ListRolesRequest(\n        project_name=project_name,\n        pagination=pagination_pb2.PaginationRequest(limit=10),\n        search=\"editor\"\n    )\n\n    response = client.ListRoles(request)\n\n    for role in response.roles:\n        print(f\"Role: {role.name} - {role.description} (Permissions: {len(role.permissions)})\")\n</code></pre> <pre><code>public void listRoles(String projectName) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    ListRolesRequest request = ListRolesRequest.newBuilder()\n            .setProjectName(projectName)\n            .setPagination(PaginationRequest.newBuilder().setLimit(10).build())\n            .setSearch(\"editor\")\n            .build();\n\n    ListRolesResponse response = client.listRoles(request);\n\n    for (Role role : response.getRolesList()) {\n        System.out.println(\"Role: \" + role.getName() + \" - \" + role.getDescription() + \n                \" (Permissions: \" + role.getPermissionsList().size() + \")\");\n    }\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface ListRolesRequest {\n    project_name: string;\n    pagination?: {\n        limit?: number;\n        cursor?: string;\n    };\n    search?: string;\n}\n\nfunction listRoles(projectName: string): void {\n    const request: ListRolesRequest = {\n        project_name: projectName,\n        pagination: {\n            limit: 10\n        },\n        search: \"editor\"\n    };\n\n    client.ListRoles(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n\n        response.roles.forEach((role: any) =&gt; {\n            console.log(`Role: ${role.name} - ${role.description} (Permissions: ${role.permissions.length})`);\n        });\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#access-control","title":"Access Control","text":""},{"location":"api-reference/permissions/#grant-permissions-and-roles","title":"Grant Permissions and Roles","text":"<p>Grants permissions and roles to a principal on a specific resource. This operation is additive - it won't remove existing permissions.</p> <p>Required Permissions: - <code>permission.get</code> on <code>/organisation/{organisation_id}/permission/{permission_name}</code> for each permission - <code>role.get</code> on <code>/organisation/{organisation_id}/role/{role_id}</code> for each role - <code>principal.assignment.create</code> on <code>/organisation/{organisation_id}/principal/{user_id}</code></p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X POST \"https://api.perms.io/permissions-service/v1/permissions/assign\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"user_id\": \"usr_123\",\n    \"resource_uri\": \"/project/456/documents/789\",\n    \"permissions\": [\"document.read\"],\n    \"roles\": [\"role_456\"]\n  }'\n</code></pre> <pre><code>func grantPermissions(client permissionsv1.PermissionsServiceClient, userId, resourceUri string, permissions, roles []string) {\n    req := &amp;permissionsv1.GrantUserPermissionsAndRolesOnResourceRequest{\n        ProjectName: \"production\",\n        UserId:      userId,\n        ResourceUri: resourceUri,\n        Permissions: permissions,\n        Roles:       roles,\n    }\n\n    _, err := client.GrantUserPermissionsAndRolesOnResource(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to grant permissions: %v\", err)\n    }\n\n    log.Printf(\"Granted permissions to user %s on resource %s\", userId, resourceUri)\n}\n</code></pre> <pre><code>async fn grant_permissions(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, user_id: &amp;str, resource_uri: &amp;str, permissions: Vec&lt;String&gt;, roles: Vec&lt;String&gt;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(GrantUserPermissionsAndRolesOnResourceRequest {\n        project_name: \"production\".to_string(),\n        user_id: user_id.to_string(),\n        resource_uri: resource_uri.to_string(),\n        permissions,\n        roles,\n    });\n\n    client.grant_user_permissions_and_roles_on_resource(request).await?;\n    println!(\"Granted permissions to user {} on resource {}\", user_id, resource_uri);\n\n    Ok(())\n}\n</code></pre> <pre><code>def grant_permissions(user_id: str, resource_uri: str, permissions: list[str], roles: list[str]):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.GrantUserPermissionsAndRolesOnResourceRequest(\n        project_name=\"production\",\n        user_id=user_id,\n        resource_uri=resource_uri,\n        permissions=permissions,\n        roles=roles\n    )\n\n    client.GrantUserPermissionsAndRolesOnResource(request)\n    print(f\"Granted permissions to user {user_id} on resource {resource_uri}\")\n</code></pre> <pre><code>public void grantPermissions(String userId, String resourceUri, List&lt;String&gt; permissions, List&lt;String&gt; roles) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    GrantUserPermissionsAndRolesOnResourceRequest request = \n            GrantUserPermissionsAndRolesOnResourceRequest.newBuilder()\n                    .setProjectName(\"production\")\n                    .setUserId(userId)\n                    .setResourceUri(resourceUri)\n                    .addAllPermissions(permissions)\n                    .addAllRoles(roles)\n                    .build();\n\n    client.grantUserPermissionsAndRolesOnResource(request);\n    System.out.println(\"Granted permissions to user \" + userId + \" on resource \" + resourceUri);\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface GrantUserPermissionsAndRolesOnResourceRequest {\n    project_name: string;\n    user_id: string;\n    resource_uri: string;\n    permissions: string[];\n    roles: string[];\n}\n\nfunction grantPermissions(userId: string, resourceUri: string, permissions: string[], roles: string[]): void {\n    const request: GrantUserPermissionsAndRolesOnResourceRequest = {\n        project_name: 'production',\n        user_id: userId,\n        resource_uri: resourceUri,\n        permissions,\n        roles\n    };\n\n    client.GrantUserPermissionsAndRolesOnResource(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Granted permissions to user ${userId} on resource ${resourceUri}`);\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#revoke-permissions-and-roles","title":"Revoke Permissions and Roles","text":"<p>Revokes specific permissions and roles from a principal on a resource.</p> <p>Required Permission: <code>principal.assignment.delete</code> on the resource URI</p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X POST \"https://api.perms.io/permissions-service/v1/permissions/revoke\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"user_id\": \"usr_123\",\n    \"resource_uri\": \"/project/456/documents/789\",\n    \"permissions\": [\"document.read\"],\n    \"roles\": [\"role_456\"]\n  }'\n</code></pre> <pre><code>func revokePermissions(client permissionsv1.PermissionsServiceClient, userId, resourceUri string, permissions, roles []string) {\n    req := &amp;permissionsv1.RevokeUserPermissionsAndRolesOnResourceRequest{\n        ProjectName: \"production\",\n        UserId:      userId,\n        ResourceUri: resourceUri,\n        Permissions: permissions,\n        Roles:       roles,\n    }\n\n    _, err := client.RevokeUserPermissionsAndRolesOnResource(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to revoke permissions: %v\", err)\n    }\n\n    log.Printf(\"Revoked permissions from user %s on resource %s\", userId, resourceUri)\n}\n</code></pre> <pre><code>async fn revoke_permissions(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, user_id: &amp;str, resource_uri: &amp;str, permissions: Vec&lt;String&gt;, roles: Vec&lt;String&gt;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(RevokeUserPermissionsAndRolesOnResourceRequest {\n        project_name: \"production\".to_string(),\n        user_id: user_id.to_string(),\n        resource_uri: resource_uri.to_string(),\n        permissions,\n        roles,\n    });\n\n    client.revoke_user_permissions_and_roles_on_resource(request).await?;\n    println!(\"Revoked permissions from user {} on resource {}\", user_id, resource_uri);\n\n    Ok(())\n}\n</code></pre> <pre><code>def revoke_permissions(user_id: str, resource_uri: str, permissions: list[str], roles: list[str]):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.RevokeUserPermissionsAndRolesOnResourceRequest(\n        project_name=\"production\",\n        user_id=user_id,\n        resource_uri=resource_uri,\n        permissions=permissions,\n        roles=roles\n    )\n\n    client.RevokeUserPermissionsAndRolesOnResource(request)\n    print(f\"Revoked permissions from user {user_id} on resource {resource_uri}\")\n</code></pre> <pre><code>public void revokePermissions(String userId, String resourceUri, List&lt;String&gt; permissions, List&lt;String&gt; roles) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    RevokeUserPermissionsAndRolesOnResourceRequest request = \n            RevokeUserPermissionsAndRolesOnResourceRequest.newBuilder()\n                    .setProjectName(\"production\")\n                    .setUserId(userId)\n                    .setResourceUri(resourceUri)\n                    .addAllPermissions(permissions)\n                    .addAllRoles(roles)\n                    .build();\n\n    client.revokeUserPermissionsAndRolesOnResource(request);\n    System.out.println(\"Revoked permissions from user \" + userId + \" on resource \" + resourceUri);\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface RevokeUserPermissionsAndRolesOnResourceRequest {\n    project_name: string;\n    user_id: string;\n    resource_uri: string;\n    permissions: string[];\n    roles: string[];\n}\n\nfunction revokePermissions(userId: string, resourceUri: string, permissions: string[], roles: string[]): void {\n    const request: RevokeUserPermissionsAndRolesOnResourceRequest = {\n        project_name: 'production',\n        user_id: userId,\n        resource_uri: resourceUri,\n        permissions,\n        roles\n    };\n\n    client.RevokeUserPermissionsAndRolesOnResource(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`Revoked permissions from user ${userId} on resource ${resourceUri}`);\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#get-principals-permissions","title":"Get Principal's Permissions","text":"<p>Retrieves all permissions and roles assigned to a principal on a specific resource.</p> <p>Required Permission: <code>principal.assignment.get</code> on the resource URI</p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X GET \"https://api.perms.io/permissions-service/v1/permissions/user/{user_id}/resource/{resource_uri}?project_name=production\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre> <pre><code>func getUserPermissions(client permissionsv1.PermissionsServiceClient, userId, resourceUri string) {\n    req := &amp;permissionsv1.GetUserPermissionsAndRolesOnResourceRequest{\n        ProjectName: \"production\",\n        UserId:      userId,\n        ResourceUri: resourceUri,\n    }\n\n    resp, err := client.GetUserPermissionsAndRolesOnResource(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to get user permissions: %v\", err)\n    }\n\n    log.Printf(\"User has %d permissions and %d roles on resource %s\", \n        len(resp.Permissions), len(resp.Roles), resourceUri)\n}\n</code></pre> <pre><code>async fn get_user_permissions(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, user_id: &amp;str, resource_uri: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(GetUserPermissionsAndRolesOnResourceRequest {\n        project_name: \"production\".to_string(),\n        user_id: user_id.to_string(),\n        resource_uri: resource_uri.to_string(),\n    });\n\n    let response = client.get_user_permissions_and_roles_on_resource(request).await?;\n    let result = response.get_ref();\n    println!(\"User has {} permissions and {} roles on resource {}\", \n        result.permissions.len(), result.roles.len(), resource_uri);\n\n    Ok(())\n}\n</code></pre> <pre><code>def get_user_permissions(user_id: str, resource_uri: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.GetUserPermissionsAndRolesOnResourceRequest(\n        project_name=\"production\",\n        user_id=user_id,\n        resource_uri=resource_uri\n    )\n\n    response = client.GetUserPermissionsAndRolesOnResource(request)\n    print(f\"User has {len(response.permissions)} permissions and {len(response.roles)} roles on resource {resource_uri}\")\n</code></pre> <pre><code>public void getUserPermissions(String userId, String resourceUri) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    GetUserPermissionsAndRolesOnResourceRequest request = \n            GetUserPermissionsAndRolesOnResourceRequest.newBuilder()\n                    .setProjectName(\"production\")\n                    .setUserId(userId)\n                    .setResourceUri(resourceUri)\n                    .build();\n\n    GetUserPermissionsAndRolesOnResourceResponse response = \n            client.getUserPermissionsAndRolesOnResource(request);\n    System.out.println(\"User has \" + response.getPermissionsList().size() + \n            \" permissions and \" + response.getRolesList().size() + \n            \" roles on resource \" + resourceUri);\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface GetUserPermissionsAndRolesOnResourceRequest {\n    project_name: string;\n    user_id: string;\n    resource_uri: string;\n}\n\nfunction getUserPermissions(userId: string, resourceUri: string): void {\n    const request: GetUserPermissionsAndRolesOnResourceRequest = {\n        project_name: 'production',\n        user_id: userId,\n        resource_uri: resourceUri\n    };\n\n    client.GetUserPermissionsAndRolesOnResource(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log(`User has ${response.permissions.length} permissions and ${response.roles.length} roles on resource ${resourceUri}`);\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#user-management","title":"User Management","text":""},{"location":"api-reference/permissions/#list-users","title":"List Users","text":"<p>Lists all users within a project.</p> <p>Required Permission: <code>principal.list</code> on <code>/organisation/{organisation_id}</code></p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X GET \"https://api.perms.io/permissions-service/v1/permissions/principals?project_name=production&amp;limit=10&amp;search=user\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre> <pre><code>func listPrincipals(client permissionsv1.PermissionsServiceClient, projectName string) {\n    req := &amp;permissionsv1.ListPrincipalsRequest{\n        ProjectName: projectName,\n        Pagination: &amp;paginationv1.PaginationRequest{\n            Limit: proto.Int32(10),\n        },\n    }\n\n    resp, err := client.ListPrincipals(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to list principals: %v\", err)\n    }\n\n    for _, principal := range resp.Principals {\n        log.Printf(\"Principal: %s\", principal)\n    }\n}\n</code></pre> <pre><code>async fn list_principals(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, project_name: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(ListPrincipalsRequest {\n        project_name: project_name.to_string(),\n        pagination: Some(PaginationRequest {\n            limit: Some(10),\n            cursor: None,\n        }),\n    });\n\n    let response = client.list_principals(request).await?;\n\n    for principal in response.get_ref().principals.iter() {\n        println!(\"Principal: {}\", principal);\n    }\n\n    Ok(())\n}\n</code></pre> <pre><code>def list_principals(project_name: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.ListPrincipalsRequest(\n        project_name=project_name,\n        pagination=pagination_pb2.PaginationRequest(limit=10)\n    )\n\n    response = client.ListPrincipals(request)\n\n    for principal in response.principals:\n        print(f\"Principal: {principal}\")\n</code></pre> <pre><code>public void listPrincipals(String projectName) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    ListPrincipalsRequest request = ListPrincipalsRequest.newBuilder()\n            .setProjectName(projectName)\n            .setPagination(PaginationRequest.newBuilder().setLimit(10).build())\n            .build();\n\n    ListPrincipalsResponse response = client.listPrincipals(request);\n\n    for (String principal : response.getPrincipalsList()) {\n        System.out.println(\"Principal: \" + principal);\n    }\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface ListPrincipalsRequest {\n    project_name: string;\n    pagination?: {\n        limit?: number;\n        cursor?: string;\n    };\n}\n\nfunction listPrincipals(projectName: string): void {\n    const request: ListPrincipalsRequest = {\n        project_name: projectName,\n        pagination: {\n            limit: 10\n        }\n    };\n\n    client.ListPrincipals(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n\n        response.principals.forEach((principal: string) =&gt; {\n            console.log(`Principal: ${principal}`);\n        });\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#get-user-permissions","title":"Get User Permissions","text":"<p>Retrieves all permission assignments for a specific user within an organization.</p> <p>Required Permission: <code>principal.assignment.list</code> on <code>/organisation/{organisation_id}/principal/{principal_id}</code></p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X GET \"https://api.perms.io/permissions-service/v1/permissions/assignments/principal/{principal_id}?project_name=production\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\"\n</code></pre> <pre><code>func getAllAssignments(client permissionsv1.PermissionsServiceClient, projectName, principalId string) {\n    req := &amp;permissionsv1.GetAllAssignmentsForPrincipalRequest{\n        ProjectName: projectName,\n        PrincipalId: principalId,\n    }\n\n    resp, err := client.GetAllAssignmentsForPrincipal(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to get assignments: %v\", err)\n    }\n\n    for _, assignment := range resp.Assignments {\n        log.Printf(\"Resource: %s, Permissions: %d, Roles: %d\", \n            assignment.ResourceUri, len(assignment.Permissions), len(assignment.Roles))\n    }\n}\n</code></pre> <pre><code>async fn get_all_assignments(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, project_name: &amp;str, principal_id: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(GetAllAssignmentsForPrincipalRequest {\n        project_name: project_name.to_string(),\n        principal_id: principal_id.to_string(),\n    });\n\n    let response = client.get_all_assignments_for_principal(request).await?;\n\n    for assignment in response.get_ref().assignments.iter() {\n        println!(\"Resource: {}, Permissions: {}, Roles: {}\", \n            assignment.resource_uri, assignment.permissions.len(), assignment.roles.len());\n    }\n\n    Ok(())\n}\n</code></pre> <pre><code>def get_all_assignments(project_name: str, principal_id: str):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.GetAllAssignmentsForPrincipalRequest(\n        project_name=project_name,\n        principal_id=principal_id\n    )\n\n    response = client.GetAllAssignmentsForPrincipal(request)\n\n    for assignment in response.assignments:\n        print(f\"Resource: {assignment.resource_uri}, Permissions: {len(assignment.permissions)}, Roles: {len(assignment.roles)}\")\n</code></pre> <pre><code>public void getAllAssignments(String projectName, String principalId) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    GetAllAssignmentsForPrincipalRequest request = \n            GetAllAssignmentsForPrincipalRequest.newBuilder()\n                    .setProjectName(projectName)\n                    .setPrincipalId(principalId)\n                    .build();\n\n    GetAllAssignmentsForPrincipalResponse response = \n            client.getAllAssignmentsForPrincipal(request);\n\n    for (Assignment assignment : response.getAssignmentsList()) {\n        System.out.println(\"Resource: \" + assignment.getResourceUri() + \n                \", Permissions: \" + assignment.getPermissionsList().size() + \n                \", Roles: \" + assignment.getRolesList().size());\n    }\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface GetAllAssignmentsForPrincipalRequest {\n    project_name: string;\n    principal_id: string;\n}\n\nfunction getAllAssignments(projectName: string, principalId: string): void {\n    const request: GetAllAssignmentsForPrincipalRequest = {\n        project_name: projectName,\n        principal_id: principalId\n    };\n\n    client.GetAllAssignmentsForPrincipal(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n\n        response.assignments.forEach((assignment: any) =&gt; {\n            console.log(`Resource: ${assignment.resource_uri}, Permissions: ${assignment.permissions.length}, Roles: ${assignment.roles.length}`);\n        });\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#permission-checking","title":"Permission Checking","text":""},{"location":"api-reference/permissions/#check-permissions","title":"Check Permissions","text":"<p>The core permission checking endpoint that determines if a principal has specific permissions on resources.</p> HTTPGoRustPythonJavaTypeScript <pre><code>curl -X POST \"https://api.perms.io/permissions-service/v1/permissions/check\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"project_name\": \"production\",\n    \"principal_id\": \"usr_123\",\n    \"resource_uris\": [\"/project/456/documents/789\", \"/project/456/documents/101\"],\n    \"permissions\": [\"document.read\", \"document.write\"]\n  }'\n</code></pre> <pre><code>func checkPermissions(client permissionsv1.PermissionsServiceClient, principalId string, resourceUris, permissions []string) {\n    req := &amp;permissionsv1.CheckPermissionRequest{\n        ProjectName:  \"production\",\n        PrincipalId:  principalId,\n        ResourceUris: resourceUris,\n        Permissions:  permissions,\n    }\n\n    resp, err := client.Check(context.Background(), req)\n    if err != nil {\n        log.Fatalf(\"Failed to check permissions: %v\", err)\n    }\n\n    if resp.Passed {\n        log.Printf(\"Permission check passed for principal %s\", principalId)\n    } else {\n        log.Printf(\"Permission check failed:\")\n        for _, missing := range resp.MissingPermissions {\n            log.Printf(\"  Resource %s missing: %v\", missing.ResourceUri, missing.MissingPermissions)\n        }\n    }\n}\n</code></pre> <pre><code>async fn check_permissions(client: &amp;mut PermissionsServiceClient&lt;Channel&gt;, principal_id: &amp;str, resource_uris: Vec&lt;String&gt;, permissions: Vec&lt;String&gt;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let request = tonic::Request::new(CheckPermissionRequest {\n        project_name: \"production\".to_string(),\n        principal_id: principal_id.to_string(),\n        resource_uris,\n        permissions,\n    });\n\n    let response = client.check(request).await?;\n    let result = response.get_ref();\n\n    if result.passed {\n        println!(\"Permission check passed for principal {}\", principal_id);\n    } else {\n        println!(\"Permission check failed:\");\n        for missing in result.missing_permissions.iter() {\n            println!(\"  Resource {} missing: {:?}\", missing.resource_uri, missing.missing_permissions);\n        }\n    }\n\n    Ok(())\n}\n</code></pre> <pre><code>def check_permissions(principal_id: str, resource_uris: list[str], permissions: list[str]):\n    channel = grpc.secure_channel('api.perms.io:443', grpc.ssl_channel_credentials())\n    client = permissions_service_pb2_grpc.PermissionsServiceStub(channel)\n\n    request = permissions_service_pb2.CheckPermissionRequest(\n        project_name=\"production\",\n        principal_id=principal_id,\n        resource_uris=resource_uris,\n        permissions=permissions\n    )\n\n    response = client.Check(request)\n\n    if response.passed:\n        print(f\"Permission check passed for principal {principal_id}\")\n    else:\n        print(\"Permission check failed:\")\n        for missing in response.missing_permissions:\n            print(f\"  Resource {missing.resource_uri} missing: {missing.missing_permissions}\")\n</code></pre> <pre><code>public void checkPermissions(String principalId, List&lt;String&gt; resourceUris, List&lt;String&gt; permissions) {\n    ManagedChannel channel = ManagedChannelBuilder.forAddress(\"api.perms.io\", 443)\n            .useTransportSecurity()\n            .build();\n\n    PermissionsServiceGrpc.PermissionsServiceBlockingStub client = \n            PermissionsServiceGrpc.newBlockingStub(channel);\n\n    CheckPermissionRequest request = CheckPermissionRequest.newBuilder()\n            .setProjectName(\"production\")\n            .setPrincipalId(principalId)\n            .addAllResourceUris(resourceUris)\n            .addAllPermissions(permissions)\n            .build();\n\n    CheckPermissionResponse response = client.check(request);\n\n    if (response.getPassed()) {\n        System.out.println(\"Permission check passed for principal \" + principalId);\n    } else {\n        System.out.println(\"Permission check failed:\");\n        for (MissingPermission missing : response.getMissingPermissionsList()) {\n            System.out.println(\"  Resource \" + missing.getResourceUri() + \n                    \" missing: \" + missing.getMissingPermissionsList());\n        }\n    }\n\n    channel.shutdown();\n}\n</code></pre> <pre><code>interface CheckPermissionRequest {\n    project_name: string;\n    principal_id: string;\n    resource_uris: string[];\n    permissions: string[];\n}\n\nfunction checkPermissions(principalId: string, resourceUris: string[], permissions: string[]): void {\n    const request: CheckPermissionRequest = {\n        project_name: 'production',\n        principal_id: principalId,\n        resource_uris: resourceUris,\n        permissions: permissions\n    };\n\n    client.Check(request, (error: grpc.ServiceError | null, response: any) =&gt; {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n\n        if (response.passed) {\n            console.log(`Permission check passed for principal ${principalId}`);\n        } else {\n            console.log('Permission check failed:');\n            response.missing_permissions.forEach((missing: any) =&gt; {\n                console.log(`  Resource ${missing.resource_uri} missing: ${missing.missing_permissions}`);\n            });\n        }\n    });\n}\n</code></pre>"},{"location":"api-reference/permissions/#resource-uri-patterns","title":"Resource URI Patterns","text":"<p>Resource URIs follow a hierarchical pattern that enables inheritance:</p>"},{"location":"api-reference/permissions/#uri-structure","title":"URI Structure","text":"<pre><code>/organisation/{org_id}/project/{project_name}/resource/{resource_id}\n</code></pre>"},{"location":"api-reference/permissions/#examples","title":"Examples","text":"<ul> <li><code>/project/456</code> - Top-level project resource</li> <li><code>/project/456/documents</code> - All documents in project 456</li> <li><code>/project/456/documents/789</code> - Specific document 789</li> <li><code>/user/123</code> - User resource</li> <li><code>/user/123/profile</code> - User's profile</li> </ul>"},{"location":"api-reference/permissions/#inheritance-rules","title":"Inheritance Rules","text":"<p>Permissions granted on parent resources automatically apply to child resources:</p> <ul> <li>Permission on <code>/project/456</code> applies to <code>/project/456/documents/789</code></li> <li>Permission on <code>/user/123</code> applies to <code>/user/123/profile</code></li> </ul>"},{"location":"api-reference/permissions/#common-rbac-patterns","title":"Common RBAC Patterns","text":""},{"location":"api-reference/permissions/#document-management-system","title":"Document Management System","text":"<pre><code>// Create permissions\npermissions := []string{\"document.read\", \"document.write\", \"document.delete\"}\n\n// Create roles\neditorRole := createRole(\"document_editor\", []string{\"document.read\", \"document.write\"})\nviewerRole := createRole(\"document_viewer\", []string{\"document.read\"})\nadminRole := createRole(\"document_admin\", []string{\"document.read\", \"document.write\", \"document.delete\"})\n\n// Grant permissions\ngrantPermissions(\"user_123\", \"/project/456/documents\", []string{}, []string{editorRole.Id})\ngrantPermissions(\"user_456\", \"/project/456/documents/789\", []string{}, []string{viewerRole.Id})\n</code></pre>"},{"location":"api-reference/permissions/#multi-tenant-application","title":"Multi-tenant Application","text":"<pre><code>// Organization-level permissions\ngrantPermissions(\"user_123\", \"/organization/789\", []string{}, []string{\"org_admin\"})\n\n// Project-level permissions  \ngrantPermissions(\"user_456\", \"/organization/789/project/456\", []string{}, []string{\"project_manager\"})\n\n// Resource-specific permissions\ngrantPermissions(\"user_789\", \"/organization/789/project/456/resource/123\", []string{\"document.read\"}, []string{})\n</code></pre>"},{"location":"api-reference/permissions/#best-practices","title":"Best Practices","text":""},{"location":"api-reference/permissions/#1-permission-naming","title":"1. Permission Naming","text":"<p>Use descriptive, hierarchical names: - <code>document.read</code> instead of <code>read</code> - <code>user.profile.update</code> instead of <code>update</code> - <code>billing.invoice.create</code> instead of <code>create</code></p>"},{"location":"api-reference/permissions/#2-resource-uri-design","title":"2. Resource URI Design","text":"<p>Design URIs to reflect your application's hierarchy: - Use consistent patterns across resources - Consider future scalability - Group related resources under common parents</p>"},{"location":"api-reference/permissions/#3-role-management","title":"3. Role Management","text":"<ul> <li>Create roles for common permission sets</li> <li>Use descriptive role names</li> <li>Regularly audit role permissions</li> <li>Consider role inheritance patterns</li> </ul>"},{"location":"api-reference/permissions/#4-performance-optimization","title":"4. Performance Optimization","text":"<ul> <li>Batch permission checks when possible</li> <li>Cache permission results where appropriate</li> <li>Use specific resource URIs rather than wildcards</li> <li>Consider permission inheritance in your URI design</li> </ul>"},{"location":"api-reference/permissions/#5-security-considerations","title":"5. Security Considerations","text":"<ul> <li>Always validate resource URIs</li> <li>Use least privilege principle</li> <li>Regularly audit permission assignments</li> <li>Monitor for permission escalation</li> </ul>"},{"location":"api-reference/permissions/#error-handling","title":"Error Handling","text":""},{"location":"api-reference/permissions/#common-error-codes","title":"Common Error Codes","text":"<ul> <li><code>INVALID_ARGUMENT</code> (3): Invalid request parameters</li> <li><code>NOT_FOUND</code> (5): Resource not found</li> <li><code>PERMISSION_DENIED</code> (7): Insufficient permissions</li> <li><code>ALREADY_EXISTS</code> (6): Resource already exists</li> </ul>"},{"location":"api-reference/permissions/#example-error-response","title":"Example Error Response","text":"<pre><code>{\n  \"error\": {\n    \"code\": 7,\n    \"message\": \"Permission denied: missing required permission 'permission.create' on resource '/organisation/org_123'\"\n  }\n}\n</code></pre>"},{"location":"api-reference/permissions/#rate-limits","title":"Rate Limits","text":"<ul> <li>Permission Checks: 10,000 requests per minute</li> <li>Management Operations: 1,000 requests per minute</li> <li>Bulk Operations: 100 requests per minute</li> </ul>"},{"location":"api-reference/permissions/#monitoring-and-metrics","title":"Monitoring and Metrics","text":"<p>The service provides metrics for: - Permission check latency - Grant/revoke operation counts - Principal assignment statistics - Resource access patterns</p> <p>These metrics are available through the organisation dashboard and usage APIs.</p>"}]}